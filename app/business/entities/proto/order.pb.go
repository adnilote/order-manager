// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: app/business/entities/proto/order.proto

package order

import (
	context "context"
	encoding_binary "encoding/binary"
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	_ "github.com/gogo/protobuf/types"
	github_com_gogo_protobuf_types "github.com/gogo/protobuf/types"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strconv "strconv"
	strings "strings"
	time "time"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type Side int32

const (
	buy  Side = 0
	sell Side = 1
)

var Side_name = map[int32]string{
	0: "buy",
	1: "sell",
}

var Side_value = map[string]int32{
	"buy":  0,
	"sell": 1,
}

func (Side) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_56c4c91da649115d, []int{0}
}

type Status int32

const (
	placing   Status = 0
	pending   Status = 1
	working   Status = 2
	cancelled Status = 3
	filled    Status = 4
	rejected  Status = 5
)

var Status_name = map[int32]string{
	0: "placing",
	1: "pending",
	2: "working",
	3: "cancelled",
	4: "filled",
	5: "rejected",
}

var Status_value = map[string]int32{
	"placing":   0,
	"pending":   1,
	"working":   2,
	"cancelled": 3,
	"filled":    4,
	"rejected":  5,
}

func (Status) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_56c4c91da649115d, []int{1}
}

type GetOrderUpdateRequest struct {
}

func (m *GetOrderUpdateRequest) Reset()      { *m = GetOrderUpdateRequest{} }
func (*GetOrderUpdateRequest) ProtoMessage() {}
func (*GetOrderUpdateRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_56c4c91da649115d, []int{0}
}
func (m *GetOrderUpdateRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetOrderUpdateRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetOrderUpdateRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetOrderUpdateRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetOrderUpdateRequest.Merge(m, src)
}
func (m *GetOrderUpdateRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetOrderUpdateRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetOrderUpdateRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetOrderUpdateRequest proto.InternalMessageInfo

type GetOrderUpdateResponse struct {
	Event string `protobuf:"bytes,1,opt,name=event,proto3" json:"event,omitempty"`
	Order *Order `protobuf:"bytes,2,opt,name=order,proto3" json:"order,omitempty"`
}

func (m *GetOrderUpdateResponse) Reset()      { *m = GetOrderUpdateResponse{} }
func (*GetOrderUpdateResponse) ProtoMessage() {}
func (*GetOrderUpdateResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_56c4c91da649115d, []int{1}
}
func (m *GetOrderUpdateResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetOrderUpdateResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetOrderUpdateResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetOrderUpdateResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetOrderUpdateResponse.Merge(m, src)
}
func (m *GetOrderUpdateResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetOrderUpdateResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetOrderUpdateResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetOrderUpdateResponse proto.InternalMessageInfo

func (m *GetOrderUpdateResponse) GetEvent() string {
	if m != nil {
		return m.Event
	}
	return ""
}

func (m *GetOrderUpdateResponse) GetOrder() *Order {
	if m != nil {
		return m.Order
	}
	return nil
}

type PlaceOrderRequest struct {
	Instrument     *Instrument `protobuf:"bytes,1,opt,name=instrument,proto3" json:"instrument,omitempty"`
	OrderType      string      `protobuf:"bytes,2,opt,name=order_type,proto3" json:"order_type,omitempty"`
	StopLoss       string      `protobuf:"bytes,3,opt,name=stop_loss,json=stopLoss,proto3" json:"stop_loss,omitempty"`
	Quantity       float64     `protobuf:"fixed64,4,opt,name=quantity,proto3" json:"quantity,omitempty"`
	Side           Side        `protobuf:"varint,5,opt,name=side,proto3,enum=order.Side" json:"side,omitempty"`
	IdDoneParentId string      `protobuf:"bytes,7,opt,name=id_done_parent_id,json=idDoneParentId,proto3" json:"id_done_parent_id,omitempty"`
	PlaceInterval  string      `protobuf:"bytes,8,opt,name=place_interval,json=placeInterval,proto3" json:"place_interval,omitempty"`
	Duration       string      `protobuf:"bytes,9,opt,name=duration,proto3" json:"duration,omitempty"`
	OcoGroup       string      `protobuf:"bytes,10,opt,name=oco_group,json=ocoGroup,proto3" json:"oco_group,omitempty"`
	TakeProfit     string      `protobuf:"bytes,11,opt,name=take_profit,json=takeProfit,proto3" json:"take_profit,omitempty"`
	StopPrice      string      `protobuf:"bytes,12,opt,name=stop_price,json=stopPrice,proto3" json:"stop_price,omitempty"`
	ClientTag      string      `protobuf:"bytes,13,opt,name=client_tag,json=clientTag,proto3" json:"client_tag,omitempty"`
	LimitPrice     string      `protobuf:"bytes,14,opt,name=limit_price,json=limitPrice,proto3" json:"limit_price,omitempty"`
	GttExpiration  string      `protobuf:"bytes,15,opt,name=gtt_expiration,json=gttExpiration,proto3" json:"gtt_expiration,omitempty"`
	Account        string      `protobuf:"bytes,16,opt,name=account,proto3" json:"account,omitempty"`
	PriceDistance  string      `protobuf:"bytes,17,opt,name=price_distance,json=priceDistance,proto3" json:"price_distance,omitempty"`
	PartQuantity   string      `protobuf:"bytes,18,opt,name=part_quantity,json=partQuantity,proto3" json:"part_quantity,omitempty"`
}

func (m *PlaceOrderRequest) Reset()      { *m = PlaceOrderRequest{} }
func (*PlaceOrderRequest) ProtoMessage() {}
func (*PlaceOrderRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_56c4c91da649115d, []int{2}
}
func (m *PlaceOrderRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PlaceOrderRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PlaceOrderRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PlaceOrderRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PlaceOrderRequest.Merge(m, src)
}
func (m *PlaceOrderRequest) XXX_Size() int {
	return m.Size()
}
func (m *PlaceOrderRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_PlaceOrderRequest.DiscardUnknown(m)
}

var xxx_messageInfo_PlaceOrderRequest proto.InternalMessageInfo

func (m *PlaceOrderRequest) GetInstrument() *Instrument {
	if m != nil {
		return m.Instrument
	}
	return nil
}

func (m *PlaceOrderRequest) GetOrderType() string {
	if m != nil {
		return m.OrderType
	}
	return ""
}

func (m *PlaceOrderRequest) GetStopLoss() string {
	if m != nil {
		return m.StopLoss
	}
	return ""
}

func (m *PlaceOrderRequest) GetQuantity() float64 {
	if m != nil {
		return m.Quantity
	}
	return 0
}

func (m *PlaceOrderRequest) GetSide() Side {
	if m != nil {
		return m.Side
	}
	return buy
}

func (m *PlaceOrderRequest) GetIdDoneParentId() string {
	if m != nil {
		return m.IdDoneParentId
	}
	return ""
}

func (m *PlaceOrderRequest) GetPlaceInterval() string {
	if m != nil {
		return m.PlaceInterval
	}
	return ""
}

func (m *PlaceOrderRequest) GetDuration() string {
	if m != nil {
		return m.Duration
	}
	return ""
}

func (m *PlaceOrderRequest) GetOcoGroup() string {
	if m != nil {
		return m.OcoGroup
	}
	return ""
}

func (m *PlaceOrderRequest) GetTakeProfit() string {
	if m != nil {
		return m.TakeProfit
	}
	return ""
}

func (m *PlaceOrderRequest) GetStopPrice() string {
	if m != nil {
		return m.StopPrice
	}
	return ""
}

func (m *PlaceOrderRequest) GetClientTag() string {
	if m != nil {
		return m.ClientTag
	}
	return ""
}

func (m *PlaceOrderRequest) GetLimitPrice() string {
	if m != nil {
		return m.LimitPrice
	}
	return ""
}

func (m *PlaceOrderRequest) GetGttExpiration() string {
	if m != nil {
		return m.GttExpiration
	}
	return ""
}

func (m *PlaceOrderRequest) GetAccount() string {
	if m != nil {
		return m.Account
	}
	return ""
}

func (m *PlaceOrderRequest) GetPriceDistance() string {
	if m != nil {
		return m.PriceDistance
	}
	return ""
}

func (m *PlaceOrderRequest) GetPartQuantity() string {
	if m != nil {
		return m.PartQuantity
	}
	return ""
}

type Instrument struct {
	Id     string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Symbol string `protobuf:"bytes,2,opt,name=symbol,proto3" json:"symbol,omitempty"`
	Type   string `protobuf:"bytes,3,opt,name=type,proto3" json:"type,omitempty"`
}

func (m *Instrument) Reset()      { *m = Instrument{} }
func (*Instrument) ProtoMessage() {}
func (*Instrument) Descriptor() ([]byte, []int) {
	return fileDescriptor_56c4c91da649115d, []int{3}
}
func (m *Instrument) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Instrument) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Instrument.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Instrument) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Instrument.Merge(m, src)
}
func (m *Instrument) XXX_Size() int {
	return m.Size()
}
func (m *Instrument) XXX_DiscardUnknown() {
	xxx_messageInfo_Instrument.DiscardUnknown(m)
}

var xxx_messageInfo_Instrument proto.InternalMessageInfo

func (m *Instrument) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Instrument) GetSymbol() string {
	if m != nil {
		return m.Symbol
	}
	return ""
}

func (m *Instrument) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

type PlaceOrderResponse struct {
	Orders []*Order `protobuf:"bytes,1,rep,name=orders,proto3" json:"orders,omitempty"`
}

func (m *PlaceOrderResponse) Reset()      { *m = PlaceOrderResponse{} }
func (*PlaceOrderResponse) ProtoMessage() {}
func (*PlaceOrderResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_56c4c91da649115d, []int{4}
}
func (m *PlaceOrderResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PlaceOrderResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PlaceOrderResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PlaceOrderResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PlaceOrderResponse.Merge(m, src)
}
func (m *PlaceOrderResponse) XXX_Size() int {
	return m.Size()
}
func (m *PlaceOrderResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_PlaceOrderResponse.DiscardUnknown(m)
}

var xxx_messageInfo_PlaceOrderResponse proto.InternalMessageInfo

func (m *PlaceOrderResponse) GetOrders() []*Order {
	if m != nil {
		return m.Orders
	}
	return nil
}

type OrderParameters struct {
	Instrument     *Instrument `protobuf:"bytes,1,opt,name=instrument,proto3" json:"instrument,omitempty"`
	OrderType      string      `protobuf:"bytes,2,opt,name=order_type,json=orderType,proto3" json:"order_type,omitempty"`
	LimitPrice     string      `protobuf:"bytes,3,opt,name=limit_price,json=limitPrice,proto3" json:"limit_price,omitempty"`
	Side           Side        `protobuf:"varint,4,opt,name=side,proto3,enum=order.Side" json:"side,omitempty"`
	IfDoneParentId string      `protobuf:"bytes,6,opt,name=if_done_parent_id,json=ifDoneParentId,proto3" json:"if_done_parent_id,omitempty"`
	PlaceInterval  string      `protobuf:"bytes,7,opt,name=place_interval,json=placeInterval,proto3" json:"place_interval,omitempty"`
	Duration       string      `protobuf:"bytes,8,opt,name=duration,proto3" json:"duration,omitempty"`
	StopPrice      string      `protobuf:"bytes,9,opt,name=stop_price,json=stopPrice,proto3" json:"stop_price,omitempty"`
	Quantity       float64     `protobuf:"fixed64,10,opt,name=quantity,proto3" json:"quantity,omitempty"`
	GttExpiration  string      `protobuf:"bytes,11,opt,name=gtt_expiration,json=gttExpiration,proto3" json:"gtt_expiration,omitempty"`
	OcoGroup       string      `protobuf:"bytes,12,opt,name=oco_group,json=ocoGroup,proto3" json:"oco_group,omitempty"`
	PriceDistance  string      `protobuf:"bytes,13,opt,name=price_distance,json=priceDistance,proto3" json:"price_distance,omitempty"`
	PartQuantity   string      `protobuf:"bytes,14,opt,name=part_quantity,json=partQuantity,proto3" json:"part_quantity,omitempty"`
}

func (m *OrderParameters) Reset()      { *m = OrderParameters{} }
func (*OrderParameters) ProtoMessage() {}
func (*OrderParameters) Descriptor() ([]byte, []int) {
	return fileDescriptor_56c4c91da649115d, []int{5}
}
func (m *OrderParameters) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OrderParameters) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OrderParameters.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OrderParameters) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OrderParameters.Merge(m, src)
}
func (m *OrderParameters) XXX_Size() int {
	return m.Size()
}
func (m *OrderParameters) XXX_DiscardUnknown() {
	xxx_messageInfo_OrderParameters.DiscardUnknown(m)
}

var xxx_messageInfo_OrderParameters proto.InternalMessageInfo

func (m *OrderParameters) GetInstrument() *Instrument {
	if m != nil {
		return m.Instrument
	}
	return nil
}

func (m *OrderParameters) GetOrderType() string {
	if m != nil {
		return m.OrderType
	}
	return ""
}

func (m *OrderParameters) GetLimitPrice() string {
	if m != nil {
		return m.LimitPrice
	}
	return ""
}

func (m *OrderParameters) GetSide() Side {
	if m != nil {
		return m.Side
	}
	return buy
}

func (m *OrderParameters) GetIfDoneParentId() string {
	if m != nil {
		return m.IfDoneParentId
	}
	return ""
}

func (m *OrderParameters) GetPlaceInterval() string {
	if m != nil {
		return m.PlaceInterval
	}
	return ""
}

func (m *OrderParameters) GetDuration() string {
	if m != nil {
		return m.Duration
	}
	return ""
}

func (m *OrderParameters) GetStopPrice() string {
	if m != nil {
		return m.StopPrice
	}
	return ""
}

func (m *OrderParameters) GetQuantity() float64 {
	if m != nil {
		return m.Quantity
	}
	return 0
}

func (m *OrderParameters) GetGttExpiration() string {
	if m != nil {
		return m.GttExpiration
	}
	return ""
}

func (m *OrderParameters) GetOcoGroup() string {
	if m != nil {
		return m.OcoGroup
	}
	return ""
}

func (m *OrderParameters) GetPriceDistance() string {
	if m != nil {
		return m.PriceDistance
	}
	return ""
}

func (m *OrderParameters) GetPartQuantity() string {
	if m != nil {
		return m.PartQuantity
	}
	return ""
}

type Order struct {
	CurrentModificationId string           `protobuf:"bytes,2,opt,name=current_modification_id,json=currentModificationId,proto3" json:"current_modification_id,omitempty"`
	PlaceTime             time.Time        `protobuf:"bytes,3,opt,name=place_time,json=placeTime,proto3,stdtime" json:"place_time"`
	Username              string           `protobuf:"bytes,4,opt,name=username,proto3" json:"username,omitempty"`
	OrderId               string           `protobuf:"bytes,5,opt,name=order_id,json=orderId,proto3" json:"order_id,omitempty"`
	OrderState            *OrderState      `protobuf:"bytes,6,opt,name=order_state,json=orderState,proto3" json:"order_state,omitempty"`
	OrderParameters       *OrderParameters `protobuf:"bytes,7,opt,name=order_parameters,json=orderParameters,proto3" json:"order_parameters,omitempty"`
	ClientTag             string           `protobuf:"bytes,8,opt,name=client_tag,json=clientTag,proto3" json:"client_tag,omitempty"`
	Account               string           `protobuf:"bytes,9,opt,name=account,proto3" json:"account,omitempty"`
}

func (m *Order) Reset()      { *m = Order{} }
func (*Order) ProtoMessage() {}
func (*Order) Descriptor() ([]byte, []int) {
	return fileDescriptor_56c4c91da649115d, []int{6}
}
func (m *Order) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Order) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Order.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Order) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Order.Merge(m, src)
}
func (m *Order) XXX_Size() int {
	return m.Size()
}
func (m *Order) XXX_DiscardUnknown() {
	xxx_messageInfo_Order.DiscardUnknown(m)
}

var xxx_messageInfo_Order proto.InternalMessageInfo

func (m *Order) GetCurrentModificationId() string {
	if m != nil {
		return m.CurrentModificationId
	}
	return ""
}

func (m *Order) GetPlaceTime() time.Time {
	if m != nil {
		return m.PlaceTime
	}
	return time.Time{}
}

func (m *Order) GetUsername() string {
	if m != nil {
		return m.Username
	}
	return ""
}

func (m *Order) GetOrderId() string {
	if m != nil {
		return m.OrderId
	}
	return ""
}

func (m *Order) GetOrderState() *OrderState {
	if m != nil {
		return m.OrderState
	}
	return nil
}

func (m *Order) GetOrderParameters() *OrderParameters {
	if m != nil {
		return m.OrderParameters
	}
	return nil
}

func (m *Order) GetClientTag() string {
	if m != nil {
		return m.ClientTag
	}
	return ""
}

func (m *Order) GetAccount() string {
	if m != nil {
		return m.Account
	}
	return ""
}

type OrderState struct {
	LastUpdateTime time.Time `protobuf:"bytes,1,opt,name=last_update_time,json=lastUpdateTime,proto3,stdtime" json:"last_update_time"`
	Status         Status    `protobuf:"varint,2,opt,name=status,proto3,enum=order.Status" json:"status,omitempty"`
	Reason         string    `protobuf:"bytes,3,opt,name=reason,proto3" json:"reason,omitempty"`
	Trades         []Trade   `protobuf:"bytes,4,rep,name=trades,proto3" json:"trades"`
}

func (m *OrderState) Reset()      { *m = OrderState{} }
func (*OrderState) ProtoMessage() {}
func (*OrderState) Descriptor() ([]byte, []int) {
	return fileDescriptor_56c4c91da649115d, []int{7}
}
func (m *OrderState) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OrderState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OrderState.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OrderState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OrderState.Merge(m, src)
}
func (m *OrderState) XXX_Size() int {
	return m.Size()
}
func (m *OrderState) XXX_DiscardUnknown() {
	xxx_messageInfo_OrderState.DiscardUnknown(m)
}

var xxx_messageInfo_OrderState proto.InternalMessageInfo

func (m *OrderState) GetLastUpdateTime() time.Time {
	if m != nil {
		return m.LastUpdateTime
	}
	return time.Time{}
}

func (m *OrderState) GetStatus() Status {
	if m != nil {
		return m.Status
	}
	return placing
}

func (m *OrderState) GetReason() string {
	if m != nil {
		return m.Reason
	}
	return ""
}

func (m *OrderState) GetTrades() []Trade {
	if m != nil {
		return m.Trades
	}
	return nil
}

type Trade struct {
	Time     time.Time `protobuf:"bytes,1,opt,name=time,proto3,stdtime" json:"time"`
	Quantity float64   `protobuf:"fixed64,2,opt,name=quantity,proto3" json:"quantity,omitempty"`
	Position int64     `protobuf:"varint,3,opt,name=position,proto3" json:"position,omitempty"`
	Price    float64   `protobuf:"fixed64,5,opt,name=price,proto3" json:"price,omitempty"`
}

func (m *Trade) Reset()      { *m = Trade{} }
func (*Trade) ProtoMessage() {}
func (*Trade) Descriptor() ([]byte, []int) {
	return fileDescriptor_56c4c91da649115d, []int{8}
}
func (m *Trade) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Trade) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Trade.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Trade) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Trade.Merge(m, src)
}
func (m *Trade) XXX_Size() int {
	return m.Size()
}
func (m *Trade) XXX_DiscardUnknown() {
	xxx_messageInfo_Trade.DiscardUnknown(m)
}

var xxx_messageInfo_Trade proto.InternalMessageInfo

func (m *Trade) GetTime() time.Time {
	if m != nil {
		return m.Time
	}
	return time.Time{}
}

func (m *Trade) GetQuantity() float64 {
	if m != nil {
		return m.Quantity
	}
	return 0
}

func (m *Trade) GetPosition() int64 {
	if m != nil {
		return m.Position
	}
	return 0
}

func (m *Trade) GetPrice() float64 {
	if m != nil {
		return m.Price
	}
	return 0
}

type GetAccountSummaryRequest struct {
	Account  string `protobuf:"bytes,1,opt,name=account,proto3" json:"account,omitempty"`
	Currency string `protobuf:"bytes,2,opt,name=currency,proto3" json:"currency,omitempty"`
}

func (m *GetAccountSummaryRequest) Reset()      { *m = GetAccountSummaryRequest{} }
func (*GetAccountSummaryRequest) ProtoMessage() {}
func (*GetAccountSummaryRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_56c4c91da649115d, []int{9}
}
func (m *GetAccountSummaryRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetAccountSummaryRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetAccountSummaryRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetAccountSummaryRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetAccountSummaryRequest.Merge(m, src)
}
func (m *GetAccountSummaryRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetAccountSummaryRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetAccountSummaryRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetAccountSummaryRequest proto.InternalMessageInfo

func (m *GetAccountSummaryRequest) GetAccount() string {
	if m != nil {
		return m.Account
	}
	return ""
}

func (m *GetAccountSummaryRequest) GetCurrency() string {
	if m != nil {
		return m.Currency
	}
	return ""
}

type GetAccountSummaryResponse struct {
	AccountSummary *AccountSummary `protobuf:"bytes,1,opt,name=account_summary,json=accountSummary,proto3" json:"account_summary,omitempty"`
}

func (m *GetAccountSummaryResponse) Reset()      { *m = GetAccountSummaryResponse{} }
func (*GetAccountSummaryResponse) ProtoMessage() {}
func (*GetAccountSummaryResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_56c4c91da649115d, []int{10}
}
func (m *GetAccountSummaryResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetAccountSummaryResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetAccountSummaryResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetAccountSummaryResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetAccountSummaryResponse.Merge(m, src)
}
func (m *GetAccountSummaryResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetAccountSummaryResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetAccountSummaryResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetAccountSummaryResponse proto.InternalMessageInfo

func (m *GetAccountSummaryResponse) GetAccountSummary() *AccountSummary {
	if m != nil {
		return m.AccountSummary
	}
	return nil
}

type AccountSummary struct {
	NetAssetValue      string      `protobuf:"bytes,1,opt,name=net_asset_value,json=netAssetValue,proto3" json:"net_asset_value,omitempty"`
	Positions          []*Position `protobuf:"bytes,2,rep,name=positions,proto3" json:"positions,omitempty"`
	Currency           string      `protobuf:"bytes,3,opt,name=currency,proto3" json:"currency,omitempty"`
	MarginUtilization  string      `protobuf:"bytes,4,opt,name=margin_utilization,json=marginUtilization,proto3" json:"margin_utilization,omitempty"`
	Timestamp          time.Time   `protobuf:"bytes,5,opt,name=timestamp,proto3,stdtime" json:"timestamp"`
	MoneyUsedForMargin string      `protobuf:"bytes,6,opt,name=money_used_for_margin,json=moneyUsedForMargin,proto3" json:"money_used_for_margin,omitempty"`
	Currencies         []*Currency `protobuf:"bytes,7,rep,name=currencies,proto3" json:"currencies,omitempty"`
	Account            string      `protobuf:"bytes,8,opt,name=account,proto3" json:"account,omitempty"`
	SessionDate        string      `protobuf:"bytes,9,opt,name=session_date,json=sessionDate,proto3" json:"session_date,omitempty"`
	FreeMoney          string      `protobuf:"bytes,10,opt,name=free_money,json=freeMoney,proto3" json:"free_money,omitempty"`
}

func (m *AccountSummary) Reset()      { *m = AccountSummary{} }
func (*AccountSummary) ProtoMessage() {}
func (*AccountSummary) Descriptor() ([]byte, []int) {
	return fileDescriptor_56c4c91da649115d, []int{11}
}
func (m *AccountSummary) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AccountSummary) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AccountSummary.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AccountSummary) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AccountSummary.Merge(m, src)
}
func (m *AccountSummary) XXX_Size() int {
	return m.Size()
}
func (m *AccountSummary) XXX_DiscardUnknown() {
	xxx_messageInfo_AccountSummary.DiscardUnknown(m)
}

var xxx_messageInfo_AccountSummary proto.InternalMessageInfo

func (m *AccountSummary) GetNetAssetValue() string {
	if m != nil {
		return m.NetAssetValue
	}
	return ""
}

func (m *AccountSummary) GetPositions() []*Position {
	if m != nil {
		return m.Positions
	}
	return nil
}

func (m *AccountSummary) GetCurrency() string {
	if m != nil {
		return m.Currency
	}
	return ""
}

func (m *AccountSummary) GetMarginUtilization() string {
	if m != nil {
		return m.MarginUtilization
	}
	return ""
}

func (m *AccountSummary) GetTimestamp() time.Time {
	if m != nil {
		return m.Timestamp
	}
	return time.Time{}
}

func (m *AccountSummary) GetMoneyUsedForMargin() string {
	if m != nil {
		return m.MoneyUsedForMargin
	}
	return ""
}

func (m *AccountSummary) GetCurrencies() []*Currency {
	if m != nil {
		return m.Currencies
	}
	return nil
}

func (m *AccountSummary) GetAccount() string {
	if m != nil {
		return m.Account
	}
	return ""
}

func (m *AccountSummary) GetSessionDate() string {
	if m != nil {
		return m.SessionDate
	}
	return ""
}

func (m *AccountSummary) GetFreeMoney() string {
	if m != nil {
		return m.FreeMoney
	}
	return ""
}

type Currency struct {
	Code           string `protobuf:"bytes,1,opt,name=code,proto3" json:"code,omitempty"`
	ConvertedValue string `protobuf:"bytes,2,opt,name=converted_value,json=convertedValue,proto3" json:"converted_value,omitempty"`
	Value          string `protobuf:"bytes,3,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *Currency) Reset()      { *m = Currency{} }
func (*Currency) ProtoMessage() {}
func (*Currency) Descriptor() ([]byte, []int) {
	return fileDescriptor_56c4c91da649115d, []int{12}
}
func (m *Currency) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Currency) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Currency.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Currency) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Currency.Merge(m, src)
}
func (m *Currency) XXX_Size() int {
	return m.Size()
}
func (m *Currency) XXX_DiscardUnknown() {
	xxx_messageInfo_Currency.DiscardUnknown(m)
}

var xxx_messageInfo_Currency proto.InternalMessageInfo

func (m *Currency) GetCode() string {
	if m != nil {
		return m.Code
	}
	return ""
}

func (m *Currency) GetConvertedValue() string {
	if m != nil {
		return m.ConvertedValue
	}
	return ""
}

func (m *Currency) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

type Position struct {
	ConvertedPnl   string `protobuf:"bytes,1,opt,name=converted_pnl,json=convertedPnl,proto3" json:"converted_pnl,omitempty"`
	SymbolType     string `protobuf:"bytes,2,opt,name=symbol_type,json=symbolType,proto3" json:"symbol_type,omitempty"`
	Currency       string `protobuf:"bytes,3,opt,name=currency,proto3" json:"currency,omitempty"`
	Id             string `protobuf:"bytes,4,opt,name=id,proto3" json:"id,omitempty"`
	Pnl            string `protobuf:"bytes,5,opt,name=pnl,proto3" json:"pnl,omitempty"`
	Price          string `protobuf:"bytes,6,opt,name=price,proto3" json:"price,omitempty"`
	Quantity       string `protobuf:"bytes,7,opt,name=quantity,proto3" json:"quantity,omitempty"`
	SymbolId       string `protobuf:"bytes,8,opt,name=symbol_id,json=symbolId,proto3" json:"symbol_id,omitempty"`
	ConvertedValue string `protobuf:"bytes,9,opt,name=converted_value,json=convertedValue,proto3" json:"converted_value,omitempty"`
	AveragePrice   string `protobuf:"bytes,10,opt,name=average_price,json=averagePrice,proto3" json:"average_price,omitempty"`
	Value          string `protobuf:"bytes,11,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *Position) Reset()      { *m = Position{} }
func (*Position) ProtoMessage() {}
func (*Position) Descriptor() ([]byte, []int) {
	return fileDescriptor_56c4c91da649115d, []int{13}
}
func (m *Position) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Position) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Position.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Position) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Position.Merge(m, src)
}
func (m *Position) XXX_Size() int {
	return m.Size()
}
func (m *Position) XXX_DiscardUnknown() {
	xxx_messageInfo_Position.DiscardUnknown(m)
}

var xxx_messageInfo_Position proto.InternalMessageInfo

func (m *Position) GetConvertedPnl() string {
	if m != nil {
		return m.ConvertedPnl
	}
	return ""
}

func (m *Position) GetSymbolType() string {
	if m != nil {
		return m.SymbolType
	}
	return ""
}

func (m *Position) GetCurrency() string {
	if m != nil {
		return m.Currency
	}
	return ""
}

func (m *Position) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Position) GetPnl() string {
	if m != nil {
		return m.Pnl
	}
	return ""
}

func (m *Position) GetPrice() string {
	if m != nil {
		return m.Price
	}
	return ""
}

func (m *Position) GetQuantity() string {
	if m != nil {
		return m.Quantity
	}
	return ""
}

func (m *Position) GetSymbolId() string {
	if m != nil {
		return m.SymbolId
	}
	return ""
}

func (m *Position) GetConvertedValue() string {
	if m != nil {
		return m.ConvertedValue
	}
	return ""
}

func (m *Position) GetAveragePrice() string {
	if m != nil {
		return m.AveragePrice
	}
	return ""
}

func (m *Position) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

type TotalPosition struct {
	Account          string      `protobuf:"bytes,12,opt,name=account,proto3" json:"account,omitempty"`
	LastUpdateTime   time.Time   `protobuf:"bytes,8,opt,name=last_update_time,json=lastUpdateTime,proto3,stdtime" json:"last_update_time"`
	Instrument       *Instrument `protobuf:"bytes,2,opt,name=instrument,proto3" json:"instrument,omitempty"`
	RealizedPnl      float64     `protobuf:"fixed64,14,opt,name=realized_pnl,json=realizedPnl,proto3" json:"realized_pnl,omitempty"`
	DailyRealizedPnl float64     `protobuf:"fixed64,15,opt,name=daily_realized_pnl,json=dailyRealizedPnl,proto3" json:"daily_realized_pnl,omitempty"`
	// string converted_pnl = 1 [json_name = "convertedPnl"];
	// string currency = 3 [json_name = "currency"];
	// string id = 4 [json_name = "id"];
	// string pnl = 5 [json_name = "pnl"];
	// string price = 6 [json_name = "price"];
	Quantity float64 `protobuf:"fixed64,7,opt,name=quantity,proto3" json:"quantity,omitempty"`
	// string symbol_id = 8;
	// string converted_value = 9 [json_name = "convertedValue"];
	AveragePrice float64 `protobuf:"fixed64,10,opt,name=average_price,json=averagePrice,proto3" json:"average_price,omitempty"`
}

func (m *TotalPosition) Reset()      { *m = TotalPosition{} }
func (*TotalPosition) ProtoMessage() {}
func (*TotalPosition) Descriptor() ([]byte, []int) {
	return fileDescriptor_56c4c91da649115d, []int{14}
}
func (m *TotalPosition) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TotalPosition) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TotalPosition.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TotalPosition) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TotalPosition.Merge(m, src)
}
func (m *TotalPosition) XXX_Size() int {
	return m.Size()
}
func (m *TotalPosition) XXX_DiscardUnknown() {
	xxx_messageInfo_TotalPosition.DiscardUnknown(m)
}

var xxx_messageInfo_TotalPosition proto.InternalMessageInfo

func (m *TotalPosition) GetAccount() string {
	if m != nil {
		return m.Account
	}
	return ""
}

func (m *TotalPosition) GetLastUpdateTime() time.Time {
	if m != nil {
		return m.LastUpdateTime
	}
	return time.Time{}
}

func (m *TotalPosition) GetInstrument() *Instrument {
	if m != nil {
		return m.Instrument
	}
	return nil
}

func (m *TotalPosition) GetRealizedPnl() float64 {
	if m != nil {
		return m.RealizedPnl
	}
	return 0
}

func (m *TotalPosition) GetDailyRealizedPnl() float64 {
	if m != nil {
		return m.DailyRealizedPnl
	}
	return 0
}

func (m *TotalPosition) GetQuantity() float64 {
	if m != nil {
		return m.Quantity
	}
	return 0
}

func (m *TotalPosition) GetAveragePrice() float64 {
	if m != nil {
		return m.AveragePrice
	}
	return 0
}

type CalculatedPosition struct {
	Account          string      `protobuf:"bytes,12,opt,name=account,proto3" json:"account,omitempty"`
	Strategy         string      `protobuf:"bytes,13,opt,name=strategy,proto3" json:"strategy,omitempty"`
	Instrument       *Instrument `protobuf:"bytes,2,opt,name=instrument,proto3" json:"instrument,omitempty"`
	LastUpdateTime   time.Time   `protobuf:"bytes,8,opt,name=last_update_time,json=lastUpdateTime,proto3,stdtime" json:"last_update_time"`
	RealizedPnl      float64     `protobuf:"fixed64,14,opt,name=realized_pnl,json=realizedPnl,proto3" json:"realized_pnl,omitempty"`
	DailyRealizedPnl float64     `protobuf:"fixed64,15,opt,name=daily_realized_pnl,json=dailyRealizedPnl,proto3" json:"daily_realized_pnl,omitempty"`
	// string converted_pnl = 1 [json_name = "convertedPnl"];
	// string currency = 3 [json_name = "currency"];
	// string id = 4 [json_name = "id"];
	// double pnl = 5 [json_name = "pnl"];
	// double price = 6 [json_name = "price"];
	Quantity float64 `protobuf:"fixed64,7,opt,name=quantity,proto3" json:"quantity,omitempty"`
	// string symbol_id = 8;
	// string converted_value = 9 [json_name = "convertedValue"];
	AveragePrice float64 `protobuf:"fixed64,10,opt,name=average_price,json=averagePrice,proto3" json:"average_price,omitempty"`
}

func (m *CalculatedPosition) Reset()      { *m = CalculatedPosition{} }
func (*CalculatedPosition) ProtoMessage() {}
func (*CalculatedPosition) Descriptor() ([]byte, []int) {
	return fileDescriptor_56c4c91da649115d, []int{15}
}
func (m *CalculatedPosition) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CalculatedPosition) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CalculatedPosition.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CalculatedPosition) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CalculatedPosition.Merge(m, src)
}
func (m *CalculatedPosition) XXX_Size() int {
	return m.Size()
}
func (m *CalculatedPosition) XXX_DiscardUnknown() {
	xxx_messageInfo_CalculatedPosition.DiscardUnknown(m)
}

var xxx_messageInfo_CalculatedPosition proto.InternalMessageInfo

func (m *CalculatedPosition) GetAccount() string {
	if m != nil {
		return m.Account
	}
	return ""
}

func (m *CalculatedPosition) GetStrategy() string {
	if m != nil {
		return m.Strategy
	}
	return ""
}

func (m *CalculatedPosition) GetInstrument() *Instrument {
	if m != nil {
		return m.Instrument
	}
	return nil
}

func (m *CalculatedPosition) GetLastUpdateTime() time.Time {
	if m != nil {
		return m.LastUpdateTime
	}
	return time.Time{}
}

func (m *CalculatedPosition) GetRealizedPnl() float64 {
	if m != nil {
		return m.RealizedPnl
	}
	return 0
}

func (m *CalculatedPosition) GetDailyRealizedPnl() float64 {
	if m != nil {
		return m.DailyRealizedPnl
	}
	return 0
}

func (m *CalculatedPosition) GetQuantity() float64 {
	if m != nil {
		return m.Quantity
	}
	return 0
}

func (m *CalculatedPosition) GetAveragePrice() float64 {
	if m != nil {
		return m.AveragePrice
	}
	return 0
}

type GetPositionRequest struct {
	Account  string `protobuf:"bytes,1,opt,name=account,proto3" json:"account,omitempty"`
	Strategy string `protobuf:"bytes,2,opt,name=strategy,proto3" json:"strategy,omitempty"`
}

func (m *GetPositionRequest) Reset()      { *m = GetPositionRequest{} }
func (*GetPositionRequest) ProtoMessage() {}
func (*GetPositionRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_56c4c91da649115d, []int{16}
}
func (m *GetPositionRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetPositionRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetPositionRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetPositionRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetPositionRequest.Merge(m, src)
}
func (m *GetPositionRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetPositionRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetPositionRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetPositionRequest proto.InternalMessageInfo

func (m *GetPositionRequest) GetAccount() string {
	if m != nil {
		return m.Account
	}
	return ""
}

func (m *GetPositionRequest) GetStrategy() string {
	if m != nil {
		return m.Strategy
	}
	return ""
}

type GetPositionResponse struct {
	CalculatedPosition *CalculatedPosition `protobuf:"bytes,1,opt,name=calculated_position,json=calculatedPosition,proto3" json:"calculated_position,omitempty"`
	TotalPosition      *TotalPosition      `protobuf:"bytes,2,opt,name=total_position,json=totalPosition,proto3" json:"total_position,omitempty"`
}

func (m *GetPositionResponse) Reset()      { *m = GetPositionResponse{} }
func (*GetPositionResponse) ProtoMessage() {}
func (*GetPositionResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_56c4c91da649115d, []int{17}
}
func (m *GetPositionResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetPositionResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetPositionResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetPositionResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetPositionResponse.Merge(m, src)
}
func (m *GetPositionResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetPositionResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetPositionResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetPositionResponse proto.InternalMessageInfo

func (m *GetPositionResponse) GetCalculatedPosition() *CalculatedPosition {
	if m != nil {
		return m.CalculatedPosition
	}
	return nil
}

func (m *GetPositionResponse) GetTotalPosition() *TotalPosition {
	if m != nil {
		return m.TotalPosition
	}
	return nil
}

func init() {
	proto.RegisterEnum("order.Side", Side_name, Side_value)
	proto.RegisterEnum("order.Status", Status_name, Status_value)
	proto.RegisterType((*GetOrderUpdateRequest)(nil), "order.GetOrderUpdateRequest")
	proto.RegisterType((*GetOrderUpdateResponse)(nil), "order.GetOrderUpdateResponse")
	proto.RegisterType((*PlaceOrderRequest)(nil), "order.PlaceOrderRequest")
	proto.RegisterType((*Instrument)(nil), "order.Instrument")
	proto.RegisterType((*PlaceOrderResponse)(nil), "order.PlaceOrderResponse")
	proto.RegisterType((*OrderParameters)(nil), "order.OrderParameters")
	proto.RegisterType((*Order)(nil), "order.Order")
	proto.RegisterType((*OrderState)(nil), "order.OrderState")
	proto.RegisterType((*Trade)(nil), "order.Trade")
	proto.RegisterType((*GetAccountSummaryRequest)(nil), "order.GetAccountSummaryRequest")
	proto.RegisterType((*GetAccountSummaryResponse)(nil), "order.GetAccountSummaryResponse")
	proto.RegisterType((*AccountSummary)(nil), "order.AccountSummary")
	proto.RegisterType((*Currency)(nil), "order.Currency")
	proto.RegisterType((*Position)(nil), "order.Position")
	proto.RegisterType((*TotalPosition)(nil), "order.TotalPosition")
	proto.RegisterType((*CalculatedPosition)(nil), "order.CalculatedPosition")
	proto.RegisterType((*GetPositionRequest)(nil), "order.GetPositionRequest")
	proto.RegisterType((*GetPositionResponse)(nil), "order.GetPositionResponse")
}

func init() {
	proto.RegisterFile("app/business/entities/proto/order.proto", fileDescriptor_56c4c91da649115d)
}

var fileDescriptor_56c4c91da649115d = []byte{
	// 1674 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xcc, 0x58, 0xcd, 0x8f, 0x23, 0x47,
	0x15, 0x77, 0xdb, 0x1e, 0x4f, 0xfb, 0xf9, 0x73, 0x2a, 0xbb, 0x9b, 0x5e, 0xc3, 0xf6, 0x4c, 0x3a,
	0x2c, 0x59, 0x56, 0xec, 0x0c, 0x31, 0x12, 0x42, 0x80, 0x90, 0xf6, 0x03, 0x96, 0x89, 0x58, 0x70,
	0x7a, 0x67, 0x11, 0x12, 0x42, 0xad, 0x9a, 0xee, 0xb2, 0x29, 0xd2, 0xee, 0xea, 0x74, 0x55, 0x0f,
	0x38, 0x27, 0xfe, 0x03, 0xf2, 0x17, 0x70, 0xe6, 0x2f, 0xe0, 0x88, 0xc4, 0x89, 0x1c, 0xf7, 0xb8,
	0xa7, 0x24, 0x33, 0x7b, 0x41, 0xe2, 0x92, 0x23, 0x47, 0x54, 0x1f, 0xdd, 0xee, 0xf6, 0x98, 0xec,
	0x24, 0x70, 0xe0, 0xd6, 0xef, 0xf7, 0xea, 0xf3, 0xf7, 0x7e, 0xef, 0xbd, 0xb2, 0xe1, 0x2d, 0x9c,
	0xa6, 0x47, 0xa7, 0x39, 0xa7, 0x09, 0xe1, 0xfc, 0x88, 0x24, 0x82, 0x0a, 0x4a, 0xf8, 0x51, 0x9a,
	0x31, 0xc1, 0x8e, 0x58, 0x16, 0x91, 0xec, 0x50, 0x7d, 0xa3, 0x1d, 0x65, 0x4c, 0xee, 0x2d, 0xa8,
	0xf8, 0x4d, 0x7e, 0x7a, 0x18, 0xb2, 0xe5, 0xd1, 0x82, 0x2d, 0x98, 0x1e, 0x79, 0x9a, 0xcf, 0x95,
	0xa5, 0xa7, 0xc9, 0x2f, 0x3d, 0x6b, 0xb2, 0xbf, 0x60, 0x6c, 0x11, 0x93, 0xf5, 0x28, 0x41, 0x97,
	0x84, 0x0b, 0xbc, 0x4c, 0xf5, 0x00, 0xef, 0x75, 0xb8, 0xfe, 0x98, 0x88, 0x9f, 0xcb, 0xb5, 0x9f,
	0xa5, 0x11, 0x16, 0xc4, 0x27, 0xef, 0xe7, 0x84, 0x0b, 0xcf, 0x87, 0x1b, 0x9b, 0x0e, 0x9e, 0xb2,
	0x84, 0x13, 0x74, 0x0d, 0x76, 0xc8, 0x19, 0x49, 0x84, 0x63, 0x1d, 0x58, 0x77, 0xba, 0xbe, 0x36,
	0x90, 0x07, 0xfa, 0x84, 0x4e, 0xf3, 0xc0, 0xba, 0xd3, 0x9b, 0xf6, 0x0f, 0xf5, 0xe1, 0xd5, 0x02,
	0xbe, 0x76, 0x79, 0x2f, 0xda, 0xb0, 0x37, 0x8b, 0x71, 0x48, 0x34, 0xaa, 0x77, 0x42, 0x6f, 0x03,
	0xd0, 0x84, 0x8b, 0x2c, 0x5f, 0x16, 0x8b, 0xf6, 0xa6, 0x7b, 0x66, 0xfa, 0x71, 0xe9, 0xf0, 0x2b,
	0x83, 0x90, 0x0b, 0xa0, 0xfc, 0x81, 0x58, 0xa5, 0x44, 0xed, 0xd8, 0xf5, 0x2b, 0x08, 0xfa, 0x0a,
	0x74, 0xb9, 0x60, 0x69, 0x10, 0x33, 0xce, 0x9d, 0x96, 0x72, 0xdb, 0x12, 0xf8, 0x29, 0xe3, 0x1c,
	0x4d, 0xc0, 0x7e, 0x3f, 0xc7, 0x92, 0xe9, 0x95, 0xd3, 0x3e, 0xb0, 0xee, 0x58, 0x7e, 0x69, 0xa3,
	0x7d, 0x68, 0x73, 0x1a, 0x11, 0x67, 0xe7, 0xc0, 0xba, 0x33, 0x9c, 0xf6, 0xcc, 0x29, 0x9e, 0xd2,
	0x88, 0xf8, 0xca, 0x81, 0xbe, 0x01, 0x7b, 0x34, 0x0a, 0x22, 0x96, 0x90, 0x20, 0xc5, 0x19, 0x49,
	0x44, 0x40, 0x23, 0x67, 0x57, 0xed, 0x30, 0xa4, 0xd1, 0x23, 0x96, 0x90, 0x99, 0x82, 0x8f, 0x23,
	0x74, 0x1b, 0x86, 0xa9, 0xbc, 0x6c, 0x40, 0x13, 0x41, 0xb2, 0x33, 0x1c, 0x3b, 0xb6, 0x1a, 0x37,
	0x50, 0xe8, 0xb1, 0x01, 0xe5, 0x71, 0xa2, 0x3c, 0xc3, 0x82, 0xb2, 0xc4, 0xe9, 0xea, 0xa3, 0x16,
	0xb6, 0xbc, 0x07, 0x0b, 0x59, 0xb0, 0xc8, 0x58, 0x9e, 0x3a, 0xa0, 0x9d, 0x2c, 0x64, 0x8f, 0xa5,
	0x8d, 0xf6, 0xa1, 0x27, 0xf0, 0x7b, 0x24, 0x48, 0x33, 0x36, 0xa7, 0xc2, 0xe9, 0x69, 0x16, 0x24,
	0x34, 0x53, 0x08, 0xba, 0x05, 0xa0, 0x58, 0x48, 0x33, 0x1a, 0x12, 0xa7, 0xaf, 0xfc, 0x8a, 0x97,
	0x99, 0x04, 0xa4, 0x3b, 0x8c, 0xa9, 0xbc, 0x82, 0xc0, 0x0b, 0x67, 0xa0, 0xdd, 0x1a, 0x39, 0xc1,
	0x0b, 0xb9, 0x7c, 0x4c, 0x97, 0x54, 0x98, 0xe9, 0x43, 0xbd, 0xbc, 0x82, 0xf4, 0xfc, 0xdb, 0x30,
	0x5c, 0x08, 0x11, 0x90, 0xdf, 0xa7, 0xd4, 0x1c, 0x7f, 0xa4, 0xef, 0xb7, 0x10, 0xe2, 0x47, 0x25,
	0x88, 0x1c, 0xd8, 0xc5, 0x61, 0xc8, 0xf2, 0x44, 0x38, 0x63, 0xe5, 0x2f, 0x4c, 0x45, 0x90, 0x5c,
	0x29, 0x88, 0x28, 0x17, 0x38, 0x09, 0x89, 0xb3, 0x67, 0x08, 0x92, 0xe8, 0x23, 0x03, 0xa2, 0x37,
	0x61, 0x90, 0xe2, 0x4c, 0x04, 0x65, 0xd0, 0x90, 0x1a, 0xd5, 0x97, 0xe0, 0xbb, 0x06, 0xf3, 0x7e,
	0x02, 0xb0, 0xd6, 0x0a, 0x1a, 0x42, 0x93, 0x46, 0x46, 0x9f, 0x4d, 0x1a, 0xa1, 0x1b, 0xd0, 0xe1,
	0xab, 0xe5, 0x29, 0x8b, 0x8d, 0x56, 0x8c, 0x85, 0x10, 0xb4, 0x95, 0x82, 0xb4, 0x44, 0xd4, 0xb7,
	0xf7, 0x3d, 0x40, 0x55, 0x8d, 0x1a, 0xd1, 0x7f, 0x0d, 0x3a, 0x4a, 0x0b, 0xdc, 0xb1, 0x0e, 0x5a,
	0x97, 0xf4, 0x6d, 0x7c, 0xde, 0xc7, 0x2d, 0x18, 0x29, 0x64, 0x86, 0x33, 0xbc, 0x24, 0x82, 0x64,
	0xfc, 0xcb, 0xc8, 0xfb, 0xd6, 0x16, 0x79, 0x77, 0x15, 0x72, 0x22, 0xd5, 0xbd, 0x11, 0x99, 0xd6,
	0xa5, 0xc8, 0x14, 0x2a, 0x6e, 0x7f, 0x9e, 0x8a, 0xe7, 0x9b, 0x2a, 0xee, 0x18, 0x15, 0xcf, 0x5f,
	0xa1, 0xe2, 0xdd, 0x57, 0xa9, 0xd8, 0xde, 0x50, 0x71, 0x5d, 0x87, 0xdd, 0x4d, 0x1d, 0x56, 0xf3,
	0x11, 0x36, 0xf2, 0xf1, 0xb2, 0xc6, 0x7a, 0xdb, 0x34, 0x56, 0xcb, 0x93, 0xfe, 0x46, 0x9e, 0x5c,
	0x96, 0xd9, 0xe0, 0x4a, 0x32, 0x1b, 0x6e, 0x91, 0xd9, 0x3f, 0x9b, 0xb0, 0xa3, 0x02, 0x8c, 0xbe,
	0x03, 0xaf, 0x87, 0x79, 0xa6, 0xb8, 0x5b, 0xb2, 0x88, 0xce, 0x69, 0xa8, 0x8e, 0x22, 0x89, 0xd4,
	0x01, 0xbb, 0x6e, 0xdc, 0x4f, 0x2a, 0xde, 0xe3, 0x08, 0x3d, 0x04, 0xd0, 0x7c, 0xca, 0x4a, 0xac,
	0x62, 0xd7, 0x9b, 0x4e, 0x0e, 0x75, 0x99, 0x3e, 0x2c, 0xca, 0xf4, 0xe1, 0x49, 0x51, 0xa6, 0x1f,
	0xd8, 0x1f, 0x7d, 0xbc, 0xdf, 0xf8, 0xf0, 0x93, 0x7d, 0xcb, 0xef, 0xaa, 0x79, 0xd2, 0x23, 0x29,
	0xcb, 0x39, 0xc9, 0x12, 0xbc, 0xd4, 0x41, 0xee, 0xfa, 0xa5, 0x8d, 0x6e, 0x82, 0xad, 0xc5, 0x43,
	0x23, 0x55, 0xc6, 0xba, 0xfe, 0xae, 0xb2, 0x8f, 0x23, 0x34, 0x85, 0x9e, 0x76, 0x71, 0x81, 0x05,
	0x51, 0x01, 0x5f, 0x6b, 0x51, 0x5d, 0xeb, 0xa9, 0x74, 0x98, 0x52, 0xaa, 0xbe, 0xd1, 0x7d, 0x18,
	0xeb, 0x39, 0x69, 0x29, 0x69, 0xa5, 0x80, 0xde, 0xf4, 0x46, 0x75, 0xe2, 0x5a, 0xf0, 0xfe, 0x88,
	0x6d, 0x64, 0x40, 0xbd, 0xd0, 0xd8, 0x9b, 0x85, 0xa6, 0x52, 0x20, 0xba, 0xb5, 0x02, 0xe1, 0xfd,
	0xdd, 0x02, 0x58, 0x1f, 0x0b, 0xfd, 0x0c, 0xc6, 0x31, 0xe6, 0x22, 0xc8, 0x55, 0x3f, 0xd2, 0x04,
	0x5a, 0x5f, 0x80, 0xc0, 0xa1, 0x9c, 0xad, 0x9b, 0x99, 0x62, 0xf1, 0x36, 0x74, 0x24, 0x11, 0x39,
	0x57, 0x11, 0x1b, 0x4e, 0x07, 0x45, 0xa2, 0x28, 0xd0, 0x37, 0x4e, 0x59, 0x3c, 0x32, 0x82, 0x39,
	0x4b, 0x4c, 0xa6, 0x19, 0x0b, 0xdd, 0x85, 0x8e, 0xc8, 0x70, 0x44, 0xb8, 0xd3, 0xae, 0x95, 0x84,
	0x13, 0x09, 0x3e, 0x68, 0xcb, 0x6d, 0x7d, 0x33, 0xc2, 0xfb, 0xa3, 0x05, 0x3b, 0x0a, 0x47, 0xdf,
	0x85, 0xf6, 0x17, 0x3e, 0xb8, 0x9a, 0x51, 0xcb, 0x93, 0xe6, 0x46, 0x9e, 0x4c, 0xc0, 0x4e, 0x19,
	0xa7, 0x2a, 0x43, 0xe4, 0x29, 0x5b, 0x7e, 0x69, 0xcb, 0x7e, 0xad, 0x33, 0x6f, 0x47, 0x4d, 0xd2,
	0x86, 0x37, 0x03, 0xe7, 0x31, 0x11, 0xf7, 0x35, 0xd3, 0x4f, 0xf3, 0xe5, 0x12, 0x67, 0xab, 0xa2,
	0x23, 0x57, 0x22, 0x62, 0xd5, 0x4b, 0xf6, 0x04, 0x6c, 0x2d, 0xeb, 0x70, 0x65, 0x64, 0x5e, 0xda,
	0xde, 0xaf, 0xe0, 0xe6, 0x96, 0x15, 0x4d, 0xfd, 0xfc, 0x21, 0x8c, 0xcc, 0x1a, 0x01, 0xd7, 0x2e,
	0xc3, 0xc0, 0x75, 0xc3, 0xda, 0xc6, 0xbc, 0x21, 0xae, 0xd9, 0xde, 0x5f, 0x5a, 0x30, 0xac, 0x0f,
	0x41, 0x5f, 0x87, 0x51, 0x42, 0x44, 0x80, 0x39, 0x27, 0x22, 0x38, 0xc3, 0x71, 0x4e, 0xcc, 0x69,
	0x07, 0x09, 0x11, 0xf7, 0x25, 0xfa, 0x0b, 0x09, 0xa2, 0x7b, 0xd0, 0x2d, 0xb8, 0x90, 0x91, 0x96,
	0xa1, 0x1a, 0x99, 0x4d, 0x67, 0x06, 0xf7, 0xd7, 0x23, 0x6a, 0x57, 0x6c, 0xd5, 0xaf, 0x88, 0xee,
	0x01, 0x5a, 0xe2, 0x6c, 0x41, 0x93, 0x20, 0x17, 0x34, 0xa6, 0x1f, 0xe8, 0x92, 0xa4, 0x33, 0x70,
	0x4f, 0x7b, 0x9e, 0xad, 0x1d, 0xe8, 0x01, 0x74, 0xcb, 0xf7, 0x96, 0x62, 0xff, 0xca, 0xa9, 0x5e,
	0x4e, 0x43, 0x6f, 0xc3, 0xf5, 0x25, 0x4b, 0xc8, 0x2a, 0xc8, 0x39, 0x89, 0x82, 0x39, 0xcb, 0x02,
	0xbd, 0x8f, 0x29, 0xd7, 0x48, 0x39, 0x9f, 0x71, 0x12, 0xfd, 0x98, 0x65, 0x4f, 0x94, 0x07, 0x1d,
	0x01, 0x98, 0x13, 0x53, 0x22, 0x93, 0xb5, 0x7a, 0xe3, 0x87, 0xe6, 0x2a, 0x7e, 0x65, 0x48, 0x35,
	0xde, 0x76, 0x3d, 0xde, 0x6f, 0x40, 0x9f, 0x13, 0xce, 0x65, 0x61, 0x93, 0x69, 0x63, 0x12, 0xb4,
	0x67, 0xb0, 0x47, 0x32, 0x2b, 0x6f, 0x01, 0xcc, 0x33, 0x42, 0x02, 0x75, 0x10, 0xf3, 0x48, 0xe9,
	0x4a, 0xe4, 0x89, 0x04, 0xbc, 0x5f, 0x83, 0x5d, 0xec, 0x29, 0xdb, 0x6d, 0xc8, 0xa2, 0x22, 0x4c,
	0xea, 0x1b, 0xbd, 0x05, 0xa3, 0x90, 0x25, 0x67, 0x24, 0x13, 0x24, 0x32, 0x51, 0xd4, 0xc2, 0x1a,
	0x96, 0xb0, 0x0e, 0xe3, 0x35, 0xd8, 0xd1, 0x6e, 0x1d, 0x14, 0x6d, 0x78, 0x7f, 0x6b, 0x82, 0x5d,
	0x44, 0x51, 0x96, 0xf0, 0xf5, 0x5a, 0x69, 0x12, 0x9b, 0x8d, 0xfa, 0x25, 0x38, 0x4b, 0x62, 0xd9,
	0x3d, 0x75, 0xf7, 0xaf, 0x3d, 0x1e, 0x35, 0xa4, 0xda, 0xeb, 0xe7, 0x09, 0x40, 0x3f, 0x2c, 0xda,
	0xe5, 0xc3, 0x62, 0x0c, 0x2d, 0xb9, 0x8f, 0xae, 0xb3, 0xf2, 0x73, 0x9d, 0x6d, 0x3a, 0x3e, 0xda,
	0xa8, 0xe5, 0xae, 0xee, 0x9f, 0xeb, 0xdc, 0x95, 0x8f, 0x55, 0x7d, 0x20, 0x1a, 0x15, 0xbd, 0x53,
	0x03, 0xc7, 0xd1, 0x36, 0x7a, 0xba, 0x5b, 0xe9, 0x79, 0x13, 0x06, 0xf8, 0x8c, 0x64, 0x78, 0x41,
	0x4c, 0x9f, 0xd5, 0x91, 0xe8, 0x1b, 0x50, 0xb7, 0xda, 0x92, 0xc3, 0x5e, 0x95, 0xc3, 0xbf, 0x36,
	0x61, 0x70, 0xc2, 0x04, 0x8e, 0x4b, 0x22, 0x2b, 0x82, 0xe8, 0xd7, 0x05, 0xb1, 0xad, 0x06, 0xdb,
	0xff, 0x45, 0x0d, 0xae, 0xbf, 0x8e, 0x9a, 0x57, 0x79, 0x1d, 0xbd, 0x01, 0xfd, 0x8c, 0xe0, 0x98,
	0x7e, 0x60, 0x82, 0x3c, 0x54, 0x65, 0xad, 0x57, 0x60, 0x32, 0xc6, 0xdf, 0x04, 0x14, 0x61, 0x1a,
	0xaf, 0x82, 0xda, 0xc0, 0x91, 0x1a, 0x38, 0x56, 0x1e, 0xbf, 0x32, 0x7a, 0x33, 0x38, 0xd5, 0xc2,
	0xba, 0x95, 0x56, 0xab, 0x4e, 0xab, 0xf7, 0x49, 0x13, 0xd0, 0x43, 0x1c, 0x87, 0x79, 0x8c, 0xa5,
	0xc8, 0x5e, 0xcd, 0xe2, 0x04, 0x6c, 0x2e, 0x32, 0x2c, 0xc8, 0x62, 0x65, 0x1e, 0x23, 0xa5, 0xfd,
	0x65, 0x18, 0xf9, 0x5f, 0x07, 0xe5, 0xff, 0x8f, 0xe1, 0x77, 0x00, 0x3d, 0x26, 0xa2, 0x2c, 0xd7,
	0x57, 0xe9, 0x53, 0x25, 0xc1, 0xcd, 0x3a, 0xc1, 0xde, 0x9f, 0x2c, 0x78, 0xad, 0xb6, 0x98, 0x69,
	0x51, 0xef, 0xc0, 0x6b, 0x61, 0x19, 0xc4, 0xa0, 0x6c, 0xa7, 0xba, 0x4d, 0xdd, 0x2c, 0xea, 0xe7,
	0xa5, 0x30, 0xfb, 0x28, 0xbc, 0x1c, 0xfa, 0xef, 0xc3, 0x50, 0xc8, 0x8c, 0x5a, 0x2f, 0xa3, 0x03,
	0x79, 0xad, 0x78, 0x23, 0x54, 0xd3, 0xcd, 0x1f, 0x88, 0xaa, 0x79, 0xf7, 0x26, 0xb4, 0xe5, 0x5b,
	0x1d, 0xed, 0x42, 0xeb, 0x34, 0x5f, 0x8d, 0x1b, 0xc8, 0x86, 0x36, 0x27, 0x71, 0x3c, 0xb6, 0xee,
	0xfe, 0x12, 0x3a, 0xfa, 0x75, 0x82, 0x7a, 0xb0, 0x2b, 0xdf, 0x83, 0x34, 0x59, 0x8c, 0x1b, 0xca,
	0x20, 0x49, 0x24, 0x0d, 0x4b, 0x1a, 0xbf, 0x63, 0xd9, 0x7b, 0xd2, 0x68, 0xa2, 0x01, 0x74, 0x43,
	0xf9, 0xbc, 0x8d, 0x63, 0x12, 0x8d, 0x5b, 0x08, 0xa0, 0x33, 0xa7, 0xea, 0xbb, 0x8d, 0xfa, 0x60,
	0x67, 0xe4, 0xb7, 0x24, 0x14, 0x24, 0x1a, 0xef, 0x4c, 0x31, 0xf4, 0xd5, 0x53, 0xeb, 0x09, 0x4e,
	0xf0, 0x82, 0x64, 0xe8, 0x5d, 0x18, 0xd6, 0x7f, 0xff, 0xa3, 0xaf, 0x9a, 0xb3, 0x6f, 0xfd, 0xbf,
	0x60, 0x72, 0xeb, 0x3f, 0x78, 0x35, 0xb9, 0x5e, 0xe3, 0x5b, 0xd6, 0x83, 0x1f, 0x3c, 0x3f, 0x77,
	0x1b, 0x2f, 0xce, 0xdd, 0xc6, 0xa7, 0xe7, 0xae, 0xf5, 0xd9, 0xb9, 0x6b, 0xfd, 0xeb, 0xdc, 0xb5,
	0xfe, 0x70, 0xe1, 0x5a, 0x7f, 0xbe, 0x70, 0xad, 0x8f, 0x2e, 0x5c, 0xeb, 0xf9, 0x85, 0x6b, 0x7d,
	0x7a, 0xe1, 0x5a, 0xff, 0xb8, 0x70, 0x1b, 0x9f, 0x5d, 0xb8, 0xd6, 0x87, 0x2f, 0xdd, 0xc6, 0xf3,
	0x97, 0x6e, 0xe3, 0xc5, 0x4b, 0xb7, 0x71, 0xda, 0x51, 0x12, 0xfe, 0xf6, 0xbf, 0x03, 0x00, 0x00,
	0xff, 0xff, 0x79, 0xed, 0xc8, 0x4f, 0x32, 0x11, 0x00, 0x00,
}

func (x Side) String() string {
	s, ok := Side_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x Status) String() string {
	s, ok := Status_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (this *GetOrderUpdateRequest) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*GetOrderUpdateRequest)
	if !ok {
		that2, ok := that.(GetOrderUpdateRequest)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *GetOrderUpdateRequest")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *GetOrderUpdateRequest but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *GetOrderUpdateRequest but is not nil && this == nil")
	}
	return nil
}
func (this *GetOrderUpdateRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetOrderUpdateRequest)
	if !ok {
		that2, ok := that.(GetOrderUpdateRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	return true
}
func (this *GetOrderUpdateResponse) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*GetOrderUpdateResponse)
	if !ok {
		that2, ok := that.(GetOrderUpdateResponse)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *GetOrderUpdateResponse")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *GetOrderUpdateResponse but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *GetOrderUpdateResponse but is not nil && this == nil")
	}
	if this.Event != that1.Event {
		return fmt.Errorf("Event this(%v) Not Equal that(%v)", this.Event, that1.Event)
	}
	if !this.Order.Equal(that1.Order) {
		return fmt.Errorf("Order this(%v) Not Equal that(%v)", this.Order, that1.Order)
	}
	return nil
}
func (this *GetOrderUpdateResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetOrderUpdateResponse)
	if !ok {
		that2, ok := that.(GetOrderUpdateResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Event != that1.Event {
		return false
	}
	if !this.Order.Equal(that1.Order) {
		return false
	}
	return true
}
func (this *PlaceOrderRequest) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*PlaceOrderRequest)
	if !ok {
		that2, ok := that.(PlaceOrderRequest)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *PlaceOrderRequest")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *PlaceOrderRequest but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *PlaceOrderRequest but is not nil && this == nil")
	}
	if !this.Instrument.Equal(that1.Instrument) {
		return fmt.Errorf("Instrument this(%v) Not Equal that(%v)", this.Instrument, that1.Instrument)
	}
	if this.OrderType != that1.OrderType {
		return fmt.Errorf("OrderType this(%v) Not Equal that(%v)", this.OrderType, that1.OrderType)
	}
	if this.StopLoss != that1.StopLoss {
		return fmt.Errorf("StopLoss this(%v) Not Equal that(%v)", this.StopLoss, that1.StopLoss)
	}
	if this.Quantity != that1.Quantity {
		return fmt.Errorf("Quantity this(%v) Not Equal that(%v)", this.Quantity, that1.Quantity)
	}
	if this.Side != that1.Side {
		return fmt.Errorf("Side this(%v) Not Equal that(%v)", this.Side, that1.Side)
	}
	if this.IdDoneParentId != that1.IdDoneParentId {
		return fmt.Errorf("IdDoneParentId this(%v) Not Equal that(%v)", this.IdDoneParentId, that1.IdDoneParentId)
	}
	if this.PlaceInterval != that1.PlaceInterval {
		return fmt.Errorf("PlaceInterval this(%v) Not Equal that(%v)", this.PlaceInterval, that1.PlaceInterval)
	}
	if this.Duration != that1.Duration {
		return fmt.Errorf("Duration this(%v) Not Equal that(%v)", this.Duration, that1.Duration)
	}
	if this.OcoGroup != that1.OcoGroup {
		return fmt.Errorf("OcoGroup this(%v) Not Equal that(%v)", this.OcoGroup, that1.OcoGroup)
	}
	if this.TakeProfit != that1.TakeProfit {
		return fmt.Errorf("TakeProfit this(%v) Not Equal that(%v)", this.TakeProfit, that1.TakeProfit)
	}
	if this.StopPrice != that1.StopPrice {
		return fmt.Errorf("StopPrice this(%v) Not Equal that(%v)", this.StopPrice, that1.StopPrice)
	}
	if this.ClientTag != that1.ClientTag {
		return fmt.Errorf("ClientTag this(%v) Not Equal that(%v)", this.ClientTag, that1.ClientTag)
	}
	if this.LimitPrice != that1.LimitPrice {
		return fmt.Errorf("LimitPrice this(%v) Not Equal that(%v)", this.LimitPrice, that1.LimitPrice)
	}
	if this.GttExpiration != that1.GttExpiration {
		return fmt.Errorf("GttExpiration this(%v) Not Equal that(%v)", this.GttExpiration, that1.GttExpiration)
	}
	if this.Account != that1.Account {
		return fmt.Errorf("Account this(%v) Not Equal that(%v)", this.Account, that1.Account)
	}
	if this.PriceDistance != that1.PriceDistance {
		return fmt.Errorf("PriceDistance this(%v) Not Equal that(%v)", this.PriceDistance, that1.PriceDistance)
	}
	if this.PartQuantity != that1.PartQuantity {
		return fmt.Errorf("PartQuantity this(%v) Not Equal that(%v)", this.PartQuantity, that1.PartQuantity)
	}
	return nil
}
func (this *PlaceOrderRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PlaceOrderRequest)
	if !ok {
		that2, ok := that.(PlaceOrderRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Instrument.Equal(that1.Instrument) {
		return false
	}
	if this.OrderType != that1.OrderType {
		return false
	}
	if this.StopLoss != that1.StopLoss {
		return false
	}
	if this.Quantity != that1.Quantity {
		return false
	}
	if this.Side != that1.Side {
		return false
	}
	if this.IdDoneParentId != that1.IdDoneParentId {
		return false
	}
	if this.PlaceInterval != that1.PlaceInterval {
		return false
	}
	if this.Duration != that1.Duration {
		return false
	}
	if this.OcoGroup != that1.OcoGroup {
		return false
	}
	if this.TakeProfit != that1.TakeProfit {
		return false
	}
	if this.StopPrice != that1.StopPrice {
		return false
	}
	if this.ClientTag != that1.ClientTag {
		return false
	}
	if this.LimitPrice != that1.LimitPrice {
		return false
	}
	if this.GttExpiration != that1.GttExpiration {
		return false
	}
	if this.Account != that1.Account {
		return false
	}
	if this.PriceDistance != that1.PriceDistance {
		return false
	}
	if this.PartQuantity != that1.PartQuantity {
		return false
	}
	return true
}
func (this *Instrument) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*Instrument)
	if !ok {
		that2, ok := that.(Instrument)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *Instrument")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *Instrument but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *Instrument but is not nil && this == nil")
	}
	if this.Id != that1.Id {
		return fmt.Errorf("Id this(%v) Not Equal that(%v)", this.Id, that1.Id)
	}
	if this.Symbol != that1.Symbol {
		return fmt.Errorf("Symbol this(%v) Not Equal that(%v)", this.Symbol, that1.Symbol)
	}
	if this.Type != that1.Type {
		return fmt.Errorf("Type this(%v) Not Equal that(%v)", this.Type, that1.Type)
	}
	return nil
}
func (this *Instrument) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Instrument)
	if !ok {
		that2, ok := that.(Instrument)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Id != that1.Id {
		return false
	}
	if this.Symbol != that1.Symbol {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	return true
}
func (this *PlaceOrderResponse) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*PlaceOrderResponse)
	if !ok {
		that2, ok := that.(PlaceOrderResponse)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *PlaceOrderResponse")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *PlaceOrderResponse but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *PlaceOrderResponse but is not nil && this == nil")
	}
	if len(this.Orders) != len(that1.Orders) {
		return fmt.Errorf("Orders this(%v) Not Equal that(%v)", len(this.Orders), len(that1.Orders))
	}
	for i := range this.Orders {
		if !this.Orders[i].Equal(that1.Orders[i]) {
			return fmt.Errorf("Orders this[%v](%v) Not Equal that[%v](%v)", i, this.Orders[i], i, that1.Orders[i])
		}
	}
	return nil
}
func (this *PlaceOrderResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PlaceOrderResponse)
	if !ok {
		that2, ok := that.(PlaceOrderResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Orders) != len(that1.Orders) {
		return false
	}
	for i := range this.Orders {
		if !this.Orders[i].Equal(that1.Orders[i]) {
			return false
		}
	}
	return true
}
func (this *OrderParameters) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*OrderParameters)
	if !ok {
		that2, ok := that.(OrderParameters)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *OrderParameters")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *OrderParameters but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *OrderParameters but is not nil && this == nil")
	}
	if !this.Instrument.Equal(that1.Instrument) {
		return fmt.Errorf("Instrument this(%v) Not Equal that(%v)", this.Instrument, that1.Instrument)
	}
	if this.OrderType != that1.OrderType {
		return fmt.Errorf("OrderType this(%v) Not Equal that(%v)", this.OrderType, that1.OrderType)
	}
	if this.LimitPrice != that1.LimitPrice {
		return fmt.Errorf("LimitPrice this(%v) Not Equal that(%v)", this.LimitPrice, that1.LimitPrice)
	}
	if this.Side != that1.Side {
		return fmt.Errorf("Side this(%v) Not Equal that(%v)", this.Side, that1.Side)
	}
	if this.IfDoneParentId != that1.IfDoneParentId {
		return fmt.Errorf("IfDoneParentId this(%v) Not Equal that(%v)", this.IfDoneParentId, that1.IfDoneParentId)
	}
	if this.PlaceInterval != that1.PlaceInterval {
		return fmt.Errorf("PlaceInterval this(%v) Not Equal that(%v)", this.PlaceInterval, that1.PlaceInterval)
	}
	if this.Duration != that1.Duration {
		return fmt.Errorf("Duration this(%v) Not Equal that(%v)", this.Duration, that1.Duration)
	}
	if this.StopPrice != that1.StopPrice {
		return fmt.Errorf("StopPrice this(%v) Not Equal that(%v)", this.StopPrice, that1.StopPrice)
	}
	if this.Quantity != that1.Quantity {
		return fmt.Errorf("Quantity this(%v) Not Equal that(%v)", this.Quantity, that1.Quantity)
	}
	if this.GttExpiration != that1.GttExpiration {
		return fmt.Errorf("GttExpiration this(%v) Not Equal that(%v)", this.GttExpiration, that1.GttExpiration)
	}
	if this.OcoGroup != that1.OcoGroup {
		return fmt.Errorf("OcoGroup this(%v) Not Equal that(%v)", this.OcoGroup, that1.OcoGroup)
	}
	if this.PriceDistance != that1.PriceDistance {
		return fmt.Errorf("PriceDistance this(%v) Not Equal that(%v)", this.PriceDistance, that1.PriceDistance)
	}
	if this.PartQuantity != that1.PartQuantity {
		return fmt.Errorf("PartQuantity this(%v) Not Equal that(%v)", this.PartQuantity, that1.PartQuantity)
	}
	return nil
}
func (this *OrderParameters) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*OrderParameters)
	if !ok {
		that2, ok := that.(OrderParameters)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Instrument.Equal(that1.Instrument) {
		return false
	}
	if this.OrderType != that1.OrderType {
		return false
	}
	if this.LimitPrice != that1.LimitPrice {
		return false
	}
	if this.Side != that1.Side {
		return false
	}
	if this.IfDoneParentId != that1.IfDoneParentId {
		return false
	}
	if this.PlaceInterval != that1.PlaceInterval {
		return false
	}
	if this.Duration != that1.Duration {
		return false
	}
	if this.StopPrice != that1.StopPrice {
		return false
	}
	if this.Quantity != that1.Quantity {
		return false
	}
	if this.GttExpiration != that1.GttExpiration {
		return false
	}
	if this.OcoGroup != that1.OcoGroup {
		return false
	}
	if this.PriceDistance != that1.PriceDistance {
		return false
	}
	if this.PartQuantity != that1.PartQuantity {
		return false
	}
	return true
}
func (this *Order) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*Order)
	if !ok {
		that2, ok := that.(Order)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *Order")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *Order but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *Order but is not nil && this == nil")
	}
	if this.CurrentModificationId != that1.CurrentModificationId {
		return fmt.Errorf("CurrentModificationId this(%v) Not Equal that(%v)", this.CurrentModificationId, that1.CurrentModificationId)
	}
	if !this.PlaceTime.Equal(that1.PlaceTime) {
		return fmt.Errorf("PlaceTime this(%v) Not Equal that(%v)", this.PlaceTime, that1.PlaceTime)
	}
	if this.Username != that1.Username {
		return fmt.Errorf("Username this(%v) Not Equal that(%v)", this.Username, that1.Username)
	}
	if this.OrderId != that1.OrderId {
		return fmt.Errorf("OrderId this(%v) Not Equal that(%v)", this.OrderId, that1.OrderId)
	}
	if !this.OrderState.Equal(that1.OrderState) {
		return fmt.Errorf("OrderState this(%v) Not Equal that(%v)", this.OrderState, that1.OrderState)
	}
	if !this.OrderParameters.Equal(that1.OrderParameters) {
		return fmt.Errorf("OrderParameters this(%v) Not Equal that(%v)", this.OrderParameters, that1.OrderParameters)
	}
	if this.ClientTag != that1.ClientTag {
		return fmt.Errorf("ClientTag this(%v) Not Equal that(%v)", this.ClientTag, that1.ClientTag)
	}
	if this.Account != that1.Account {
		return fmt.Errorf("Account this(%v) Not Equal that(%v)", this.Account, that1.Account)
	}
	return nil
}
func (this *Order) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Order)
	if !ok {
		that2, ok := that.(Order)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.CurrentModificationId != that1.CurrentModificationId {
		return false
	}
	if !this.PlaceTime.Equal(that1.PlaceTime) {
		return false
	}
	if this.Username != that1.Username {
		return false
	}
	if this.OrderId != that1.OrderId {
		return false
	}
	if !this.OrderState.Equal(that1.OrderState) {
		return false
	}
	if !this.OrderParameters.Equal(that1.OrderParameters) {
		return false
	}
	if this.ClientTag != that1.ClientTag {
		return false
	}
	if this.Account != that1.Account {
		return false
	}
	return true
}
func (this *OrderState) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*OrderState)
	if !ok {
		that2, ok := that.(OrderState)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *OrderState")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *OrderState but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *OrderState but is not nil && this == nil")
	}
	if !this.LastUpdateTime.Equal(that1.LastUpdateTime) {
		return fmt.Errorf("LastUpdateTime this(%v) Not Equal that(%v)", this.LastUpdateTime, that1.LastUpdateTime)
	}
	if this.Status != that1.Status {
		return fmt.Errorf("Status this(%v) Not Equal that(%v)", this.Status, that1.Status)
	}
	if this.Reason != that1.Reason {
		return fmt.Errorf("Reason this(%v) Not Equal that(%v)", this.Reason, that1.Reason)
	}
	if len(this.Trades) != len(that1.Trades) {
		return fmt.Errorf("Trades this(%v) Not Equal that(%v)", len(this.Trades), len(that1.Trades))
	}
	for i := range this.Trades {
		if !this.Trades[i].Equal(&that1.Trades[i]) {
			return fmt.Errorf("Trades this[%v](%v) Not Equal that[%v](%v)", i, this.Trades[i], i, that1.Trades[i])
		}
	}
	return nil
}
func (this *OrderState) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*OrderState)
	if !ok {
		that2, ok := that.(OrderState)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.LastUpdateTime.Equal(that1.LastUpdateTime) {
		return false
	}
	if this.Status != that1.Status {
		return false
	}
	if this.Reason != that1.Reason {
		return false
	}
	if len(this.Trades) != len(that1.Trades) {
		return false
	}
	for i := range this.Trades {
		if !this.Trades[i].Equal(&that1.Trades[i]) {
			return false
		}
	}
	return true
}
func (this *Trade) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*Trade)
	if !ok {
		that2, ok := that.(Trade)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *Trade")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *Trade but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *Trade but is not nil && this == nil")
	}
	if !this.Time.Equal(that1.Time) {
		return fmt.Errorf("Time this(%v) Not Equal that(%v)", this.Time, that1.Time)
	}
	if this.Quantity != that1.Quantity {
		return fmt.Errorf("Quantity this(%v) Not Equal that(%v)", this.Quantity, that1.Quantity)
	}
	if this.Position != that1.Position {
		return fmt.Errorf("Position this(%v) Not Equal that(%v)", this.Position, that1.Position)
	}
	if this.Price != that1.Price {
		return fmt.Errorf("Price this(%v) Not Equal that(%v)", this.Price, that1.Price)
	}
	return nil
}
func (this *Trade) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Trade)
	if !ok {
		that2, ok := that.(Trade)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Time.Equal(that1.Time) {
		return false
	}
	if this.Quantity != that1.Quantity {
		return false
	}
	if this.Position != that1.Position {
		return false
	}
	if this.Price != that1.Price {
		return false
	}
	return true
}
func (this *GetAccountSummaryRequest) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*GetAccountSummaryRequest)
	if !ok {
		that2, ok := that.(GetAccountSummaryRequest)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *GetAccountSummaryRequest")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *GetAccountSummaryRequest but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *GetAccountSummaryRequest but is not nil && this == nil")
	}
	if this.Account != that1.Account {
		return fmt.Errorf("Account this(%v) Not Equal that(%v)", this.Account, that1.Account)
	}
	if this.Currency != that1.Currency {
		return fmt.Errorf("Currency this(%v) Not Equal that(%v)", this.Currency, that1.Currency)
	}
	return nil
}
func (this *GetAccountSummaryRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetAccountSummaryRequest)
	if !ok {
		that2, ok := that.(GetAccountSummaryRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Account != that1.Account {
		return false
	}
	if this.Currency != that1.Currency {
		return false
	}
	return true
}
func (this *GetAccountSummaryResponse) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*GetAccountSummaryResponse)
	if !ok {
		that2, ok := that.(GetAccountSummaryResponse)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *GetAccountSummaryResponse")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *GetAccountSummaryResponse but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *GetAccountSummaryResponse but is not nil && this == nil")
	}
	if !this.AccountSummary.Equal(that1.AccountSummary) {
		return fmt.Errorf("AccountSummary this(%v) Not Equal that(%v)", this.AccountSummary, that1.AccountSummary)
	}
	return nil
}
func (this *GetAccountSummaryResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetAccountSummaryResponse)
	if !ok {
		that2, ok := that.(GetAccountSummaryResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AccountSummary.Equal(that1.AccountSummary) {
		return false
	}
	return true
}
func (this *AccountSummary) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*AccountSummary)
	if !ok {
		that2, ok := that.(AccountSummary)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *AccountSummary")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *AccountSummary but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *AccountSummary but is not nil && this == nil")
	}
	if this.NetAssetValue != that1.NetAssetValue {
		return fmt.Errorf("NetAssetValue this(%v) Not Equal that(%v)", this.NetAssetValue, that1.NetAssetValue)
	}
	if len(this.Positions) != len(that1.Positions) {
		return fmt.Errorf("Positions this(%v) Not Equal that(%v)", len(this.Positions), len(that1.Positions))
	}
	for i := range this.Positions {
		if !this.Positions[i].Equal(that1.Positions[i]) {
			return fmt.Errorf("Positions this[%v](%v) Not Equal that[%v](%v)", i, this.Positions[i], i, that1.Positions[i])
		}
	}
	if this.Currency != that1.Currency {
		return fmt.Errorf("Currency this(%v) Not Equal that(%v)", this.Currency, that1.Currency)
	}
	if this.MarginUtilization != that1.MarginUtilization {
		return fmt.Errorf("MarginUtilization this(%v) Not Equal that(%v)", this.MarginUtilization, that1.MarginUtilization)
	}
	if !this.Timestamp.Equal(that1.Timestamp) {
		return fmt.Errorf("Timestamp this(%v) Not Equal that(%v)", this.Timestamp, that1.Timestamp)
	}
	if this.MoneyUsedForMargin != that1.MoneyUsedForMargin {
		return fmt.Errorf("MoneyUsedForMargin this(%v) Not Equal that(%v)", this.MoneyUsedForMargin, that1.MoneyUsedForMargin)
	}
	if len(this.Currencies) != len(that1.Currencies) {
		return fmt.Errorf("Currencies this(%v) Not Equal that(%v)", len(this.Currencies), len(that1.Currencies))
	}
	for i := range this.Currencies {
		if !this.Currencies[i].Equal(that1.Currencies[i]) {
			return fmt.Errorf("Currencies this[%v](%v) Not Equal that[%v](%v)", i, this.Currencies[i], i, that1.Currencies[i])
		}
	}
	if this.Account != that1.Account {
		return fmt.Errorf("Account this(%v) Not Equal that(%v)", this.Account, that1.Account)
	}
	if this.SessionDate != that1.SessionDate {
		return fmt.Errorf("SessionDate this(%v) Not Equal that(%v)", this.SessionDate, that1.SessionDate)
	}
	if this.FreeMoney != that1.FreeMoney {
		return fmt.Errorf("FreeMoney this(%v) Not Equal that(%v)", this.FreeMoney, that1.FreeMoney)
	}
	return nil
}
func (this *AccountSummary) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AccountSummary)
	if !ok {
		that2, ok := that.(AccountSummary)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.NetAssetValue != that1.NetAssetValue {
		return false
	}
	if len(this.Positions) != len(that1.Positions) {
		return false
	}
	for i := range this.Positions {
		if !this.Positions[i].Equal(that1.Positions[i]) {
			return false
		}
	}
	if this.Currency != that1.Currency {
		return false
	}
	if this.MarginUtilization != that1.MarginUtilization {
		return false
	}
	if !this.Timestamp.Equal(that1.Timestamp) {
		return false
	}
	if this.MoneyUsedForMargin != that1.MoneyUsedForMargin {
		return false
	}
	if len(this.Currencies) != len(that1.Currencies) {
		return false
	}
	for i := range this.Currencies {
		if !this.Currencies[i].Equal(that1.Currencies[i]) {
			return false
		}
	}
	if this.Account != that1.Account {
		return false
	}
	if this.SessionDate != that1.SessionDate {
		return false
	}
	if this.FreeMoney != that1.FreeMoney {
		return false
	}
	return true
}
func (this *Currency) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*Currency)
	if !ok {
		that2, ok := that.(Currency)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *Currency")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *Currency but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *Currency but is not nil && this == nil")
	}
	if this.Code != that1.Code {
		return fmt.Errorf("Code this(%v) Not Equal that(%v)", this.Code, that1.Code)
	}
	if this.ConvertedValue != that1.ConvertedValue {
		return fmt.Errorf("ConvertedValue this(%v) Not Equal that(%v)", this.ConvertedValue, that1.ConvertedValue)
	}
	if this.Value != that1.Value {
		return fmt.Errorf("Value this(%v) Not Equal that(%v)", this.Value, that1.Value)
	}
	return nil
}
func (this *Currency) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Currency)
	if !ok {
		that2, ok := that.(Currency)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Code != that1.Code {
		return false
	}
	if this.ConvertedValue != that1.ConvertedValue {
		return false
	}
	if this.Value != that1.Value {
		return false
	}
	return true
}
func (this *Position) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*Position)
	if !ok {
		that2, ok := that.(Position)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *Position")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *Position but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *Position but is not nil && this == nil")
	}
	if this.ConvertedPnl != that1.ConvertedPnl {
		return fmt.Errorf("ConvertedPnl this(%v) Not Equal that(%v)", this.ConvertedPnl, that1.ConvertedPnl)
	}
	if this.SymbolType != that1.SymbolType {
		return fmt.Errorf("SymbolType this(%v) Not Equal that(%v)", this.SymbolType, that1.SymbolType)
	}
	if this.Currency != that1.Currency {
		return fmt.Errorf("Currency this(%v) Not Equal that(%v)", this.Currency, that1.Currency)
	}
	if this.Id != that1.Id {
		return fmt.Errorf("Id this(%v) Not Equal that(%v)", this.Id, that1.Id)
	}
	if this.Pnl != that1.Pnl {
		return fmt.Errorf("Pnl this(%v) Not Equal that(%v)", this.Pnl, that1.Pnl)
	}
	if this.Price != that1.Price {
		return fmt.Errorf("Price this(%v) Not Equal that(%v)", this.Price, that1.Price)
	}
	if this.Quantity != that1.Quantity {
		return fmt.Errorf("Quantity this(%v) Not Equal that(%v)", this.Quantity, that1.Quantity)
	}
	if this.SymbolId != that1.SymbolId {
		return fmt.Errorf("SymbolId this(%v) Not Equal that(%v)", this.SymbolId, that1.SymbolId)
	}
	if this.ConvertedValue != that1.ConvertedValue {
		return fmt.Errorf("ConvertedValue this(%v) Not Equal that(%v)", this.ConvertedValue, that1.ConvertedValue)
	}
	if this.AveragePrice != that1.AveragePrice {
		return fmt.Errorf("AveragePrice this(%v) Not Equal that(%v)", this.AveragePrice, that1.AveragePrice)
	}
	if this.Value != that1.Value {
		return fmt.Errorf("Value this(%v) Not Equal that(%v)", this.Value, that1.Value)
	}
	return nil
}
func (this *Position) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Position)
	if !ok {
		that2, ok := that.(Position)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ConvertedPnl != that1.ConvertedPnl {
		return false
	}
	if this.SymbolType != that1.SymbolType {
		return false
	}
	if this.Currency != that1.Currency {
		return false
	}
	if this.Id != that1.Id {
		return false
	}
	if this.Pnl != that1.Pnl {
		return false
	}
	if this.Price != that1.Price {
		return false
	}
	if this.Quantity != that1.Quantity {
		return false
	}
	if this.SymbolId != that1.SymbolId {
		return false
	}
	if this.ConvertedValue != that1.ConvertedValue {
		return false
	}
	if this.AveragePrice != that1.AveragePrice {
		return false
	}
	if this.Value != that1.Value {
		return false
	}
	return true
}
func (this *TotalPosition) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*TotalPosition)
	if !ok {
		that2, ok := that.(TotalPosition)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *TotalPosition")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *TotalPosition but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *TotalPosition but is not nil && this == nil")
	}
	if this.Account != that1.Account {
		return fmt.Errorf("Account this(%v) Not Equal that(%v)", this.Account, that1.Account)
	}
	if !this.LastUpdateTime.Equal(that1.LastUpdateTime) {
		return fmt.Errorf("LastUpdateTime this(%v) Not Equal that(%v)", this.LastUpdateTime, that1.LastUpdateTime)
	}
	if !this.Instrument.Equal(that1.Instrument) {
		return fmt.Errorf("Instrument this(%v) Not Equal that(%v)", this.Instrument, that1.Instrument)
	}
	if this.RealizedPnl != that1.RealizedPnl {
		return fmt.Errorf("RealizedPnl this(%v) Not Equal that(%v)", this.RealizedPnl, that1.RealizedPnl)
	}
	if this.DailyRealizedPnl != that1.DailyRealizedPnl {
		return fmt.Errorf("DailyRealizedPnl this(%v) Not Equal that(%v)", this.DailyRealizedPnl, that1.DailyRealizedPnl)
	}
	if this.Quantity != that1.Quantity {
		return fmt.Errorf("Quantity this(%v) Not Equal that(%v)", this.Quantity, that1.Quantity)
	}
	if this.AveragePrice != that1.AveragePrice {
		return fmt.Errorf("AveragePrice this(%v) Not Equal that(%v)", this.AveragePrice, that1.AveragePrice)
	}
	return nil
}
func (this *TotalPosition) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TotalPosition)
	if !ok {
		that2, ok := that.(TotalPosition)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Account != that1.Account {
		return false
	}
	if !this.LastUpdateTime.Equal(that1.LastUpdateTime) {
		return false
	}
	if !this.Instrument.Equal(that1.Instrument) {
		return false
	}
	if this.RealizedPnl != that1.RealizedPnl {
		return false
	}
	if this.DailyRealizedPnl != that1.DailyRealizedPnl {
		return false
	}
	if this.Quantity != that1.Quantity {
		return false
	}
	if this.AveragePrice != that1.AveragePrice {
		return false
	}
	return true
}
func (this *CalculatedPosition) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*CalculatedPosition)
	if !ok {
		that2, ok := that.(CalculatedPosition)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *CalculatedPosition")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *CalculatedPosition but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *CalculatedPosition but is not nil && this == nil")
	}
	if this.Account != that1.Account {
		return fmt.Errorf("Account this(%v) Not Equal that(%v)", this.Account, that1.Account)
	}
	if this.Strategy != that1.Strategy {
		return fmt.Errorf("Strategy this(%v) Not Equal that(%v)", this.Strategy, that1.Strategy)
	}
	if !this.Instrument.Equal(that1.Instrument) {
		return fmt.Errorf("Instrument this(%v) Not Equal that(%v)", this.Instrument, that1.Instrument)
	}
	if !this.LastUpdateTime.Equal(that1.LastUpdateTime) {
		return fmt.Errorf("LastUpdateTime this(%v) Not Equal that(%v)", this.LastUpdateTime, that1.LastUpdateTime)
	}
	if this.RealizedPnl != that1.RealizedPnl {
		return fmt.Errorf("RealizedPnl this(%v) Not Equal that(%v)", this.RealizedPnl, that1.RealizedPnl)
	}
	if this.DailyRealizedPnl != that1.DailyRealizedPnl {
		return fmt.Errorf("DailyRealizedPnl this(%v) Not Equal that(%v)", this.DailyRealizedPnl, that1.DailyRealizedPnl)
	}
	if this.Quantity != that1.Quantity {
		return fmt.Errorf("Quantity this(%v) Not Equal that(%v)", this.Quantity, that1.Quantity)
	}
	if this.AveragePrice != that1.AveragePrice {
		return fmt.Errorf("AveragePrice this(%v) Not Equal that(%v)", this.AveragePrice, that1.AveragePrice)
	}
	return nil
}
func (this *CalculatedPosition) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CalculatedPosition)
	if !ok {
		that2, ok := that.(CalculatedPosition)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Account != that1.Account {
		return false
	}
	if this.Strategy != that1.Strategy {
		return false
	}
	if !this.Instrument.Equal(that1.Instrument) {
		return false
	}
	if !this.LastUpdateTime.Equal(that1.LastUpdateTime) {
		return false
	}
	if this.RealizedPnl != that1.RealizedPnl {
		return false
	}
	if this.DailyRealizedPnl != that1.DailyRealizedPnl {
		return false
	}
	if this.Quantity != that1.Quantity {
		return false
	}
	if this.AveragePrice != that1.AveragePrice {
		return false
	}
	return true
}
func (this *GetPositionRequest) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*GetPositionRequest)
	if !ok {
		that2, ok := that.(GetPositionRequest)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *GetPositionRequest")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *GetPositionRequest but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *GetPositionRequest but is not nil && this == nil")
	}
	if this.Account != that1.Account {
		return fmt.Errorf("Account this(%v) Not Equal that(%v)", this.Account, that1.Account)
	}
	if this.Strategy != that1.Strategy {
		return fmt.Errorf("Strategy this(%v) Not Equal that(%v)", this.Strategy, that1.Strategy)
	}
	return nil
}
func (this *GetPositionRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetPositionRequest)
	if !ok {
		that2, ok := that.(GetPositionRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Account != that1.Account {
		return false
	}
	if this.Strategy != that1.Strategy {
		return false
	}
	return true
}
func (this *GetPositionResponse) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*GetPositionResponse)
	if !ok {
		that2, ok := that.(GetPositionResponse)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *GetPositionResponse")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *GetPositionResponse but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *GetPositionResponse but is not nil && this == nil")
	}
	if !this.CalculatedPosition.Equal(that1.CalculatedPosition) {
		return fmt.Errorf("CalculatedPosition this(%v) Not Equal that(%v)", this.CalculatedPosition, that1.CalculatedPosition)
	}
	if !this.TotalPosition.Equal(that1.TotalPosition) {
		return fmt.Errorf("TotalPosition this(%v) Not Equal that(%v)", this.TotalPosition, that1.TotalPosition)
	}
	return nil
}
func (this *GetPositionResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetPositionResponse)
	if !ok {
		that2, ok := that.(GetPositionResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.CalculatedPosition.Equal(that1.CalculatedPosition) {
		return false
	}
	if !this.TotalPosition.Equal(that1.TotalPosition) {
		return false
	}
	return true
}
func (this *GetOrderUpdateRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 4)
	s = append(s, "&order.GetOrderUpdateRequest{")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GetOrderUpdateResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&order.GetOrderUpdateResponse{")
	s = append(s, "Event: "+fmt.Sprintf("%#v", this.Event)+",\n")
	if this.Order != nil {
		s = append(s, "Order: "+fmt.Sprintf("%#v", this.Order)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *PlaceOrderRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 21)
	s = append(s, "&order.PlaceOrderRequest{")
	if this.Instrument != nil {
		s = append(s, "Instrument: "+fmt.Sprintf("%#v", this.Instrument)+",\n")
	}
	s = append(s, "OrderType: "+fmt.Sprintf("%#v", this.OrderType)+",\n")
	s = append(s, "StopLoss: "+fmt.Sprintf("%#v", this.StopLoss)+",\n")
	s = append(s, "Quantity: "+fmt.Sprintf("%#v", this.Quantity)+",\n")
	s = append(s, "Side: "+fmt.Sprintf("%#v", this.Side)+",\n")
	s = append(s, "IdDoneParentId: "+fmt.Sprintf("%#v", this.IdDoneParentId)+",\n")
	s = append(s, "PlaceInterval: "+fmt.Sprintf("%#v", this.PlaceInterval)+",\n")
	s = append(s, "Duration: "+fmt.Sprintf("%#v", this.Duration)+",\n")
	s = append(s, "OcoGroup: "+fmt.Sprintf("%#v", this.OcoGroup)+",\n")
	s = append(s, "TakeProfit: "+fmt.Sprintf("%#v", this.TakeProfit)+",\n")
	s = append(s, "StopPrice: "+fmt.Sprintf("%#v", this.StopPrice)+",\n")
	s = append(s, "ClientTag: "+fmt.Sprintf("%#v", this.ClientTag)+",\n")
	s = append(s, "LimitPrice: "+fmt.Sprintf("%#v", this.LimitPrice)+",\n")
	s = append(s, "GttExpiration: "+fmt.Sprintf("%#v", this.GttExpiration)+",\n")
	s = append(s, "Account: "+fmt.Sprintf("%#v", this.Account)+",\n")
	s = append(s, "PriceDistance: "+fmt.Sprintf("%#v", this.PriceDistance)+",\n")
	s = append(s, "PartQuantity: "+fmt.Sprintf("%#v", this.PartQuantity)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Instrument) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&order.Instrument{")
	s = append(s, "Id: "+fmt.Sprintf("%#v", this.Id)+",\n")
	s = append(s, "Symbol: "+fmt.Sprintf("%#v", this.Symbol)+",\n")
	s = append(s, "Type: "+fmt.Sprintf("%#v", this.Type)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *PlaceOrderResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&order.PlaceOrderResponse{")
	if this.Orders != nil {
		s = append(s, "Orders: "+fmt.Sprintf("%#v", this.Orders)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *OrderParameters) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 17)
	s = append(s, "&order.OrderParameters{")
	if this.Instrument != nil {
		s = append(s, "Instrument: "+fmt.Sprintf("%#v", this.Instrument)+",\n")
	}
	s = append(s, "OrderType: "+fmt.Sprintf("%#v", this.OrderType)+",\n")
	s = append(s, "LimitPrice: "+fmt.Sprintf("%#v", this.LimitPrice)+",\n")
	s = append(s, "Side: "+fmt.Sprintf("%#v", this.Side)+",\n")
	s = append(s, "IfDoneParentId: "+fmt.Sprintf("%#v", this.IfDoneParentId)+",\n")
	s = append(s, "PlaceInterval: "+fmt.Sprintf("%#v", this.PlaceInterval)+",\n")
	s = append(s, "Duration: "+fmt.Sprintf("%#v", this.Duration)+",\n")
	s = append(s, "StopPrice: "+fmt.Sprintf("%#v", this.StopPrice)+",\n")
	s = append(s, "Quantity: "+fmt.Sprintf("%#v", this.Quantity)+",\n")
	s = append(s, "GttExpiration: "+fmt.Sprintf("%#v", this.GttExpiration)+",\n")
	s = append(s, "OcoGroup: "+fmt.Sprintf("%#v", this.OcoGroup)+",\n")
	s = append(s, "PriceDistance: "+fmt.Sprintf("%#v", this.PriceDistance)+",\n")
	s = append(s, "PartQuantity: "+fmt.Sprintf("%#v", this.PartQuantity)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Order) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 12)
	s = append(s, "&order.Order{")
	s = append(s, "CurrentModificationId: "+fmt.Sprintf("%#v", this.CurrentModificationId)+",\n")
	s = append(s, "PlaceTime: "+fmt.Sprintf("%#v", this.PlaceTime)+",\n")
	s = append(s, "Username: "+fmt.Sprintf("%#v", this.Username)+",\n")
	s = append(s, "OrderId: "+fmt.Sprintf("%#v", this.OrderId)+",\n")
	if this.OrderState != nil {
		s = append(s, "OrderState: "+fmt.Sprintf("%#v", this.OrderState)+",\n")
	}
	if this.OrderParameters != nil {
		s = append(s, "OrderParameters: "+fmt.Sprintf("%#v", this.OrderParameters)+",\n")
	}
	s = append(s, "ClientTag: "+fmt.Sprintf("%#v", this.ClientTag)+",\n")
	s = append(s, "Account: "+fmt.Sprintf("%#v", this.Account)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *OrderState) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&order.OrderState{")
	s = append(s, "LastUpdateTime: "+fmt.Sprintf("%#v", this.LastUpdateTime)+",\n")
	s = append(s, "Status: "+fmt.Sprintf("%#v", this.Status)+",\n")
	s = append(s, "Reason: "+fmt.Sprintf("%#v", this.Reason)+",\n")
	if this.Trades != nil {
		vs := make([]Trade, len(this.Trades))
		for i := range vs {
			vs[i] = this.Trades[i]
		}
		s = append(s, "Trades: "+fmt.Sprintf("%#v", vs)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Trade) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&order.Trade{")
	s = append(s, "Time: "+fmt.Sprintf("%#v", this.Time)+",\n")
	s = append(s, "Quantity: "+fmt.Sprintf("%#v", this.Quantity)+",\n")
	s = append(s, "Position: "+fmt.Sprintf("%#v", this.Position)+",\n")
	s = append(s, "Price: "+fmt.Sprintf("%#v", this.Price)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GetAccountSummaryRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&order.GetAccountSummaryRequest{")
	s = append(s, "Account: "+fmt.Sprintf("%#v", this.Account)+",\n")
	s = append(s, "Currency: "+fmt.Sprintf("%#v", this.Currency)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GetAccountSummaryResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&order.GetAccountSummaryResponse{")
	if this.AccountSummary != nil {
		s = append(s, "AccountSummary: "+fmt.Sprintf("%#v", this.AccountSummary)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AccountSummary) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 14)
	s = append(s, "&order.AccountSummary{")
	s = append(s, "NetAssetValue: "+fmt.Sprintf("%#v", this.NetAssetValue)+",\n")
	if this.Positions != nil {
		s = append(s, "Positions: "+fmt.Sprintf("%#v", this.Positions)+",\n")
	}
	s = append(s, "Currency: "+fmt.Sprintf("%#v", this.Currency)+",\n")
	s = append(s, "MarginUtilization: "+fmt.Sprintf("%#v", this.MarginUtilization)+",\n")
	s = append(s, "Timestamp: "+fmt.Sprintf("%#v", this.Timestamp)+",\n")
	s = append(s, "MoneyUsedForMargin: "+fmt.Sprintf("%#v", this.MoneyUsedForMargin)+",\n")
	if this.Currencies != nil {
		s = append(s, "Currencies: "+fmt.Sprintf("%#v", this.Currencies)+",\n")
	}
	s = append(s, "Account: "+fmt.Sprintf("%#v", this.Account)+",\n")
	s = append(s, "SessionDate: "+fmt.Sprintf("%#v", this.SessionDate)+",\n")
	s = append(s, "FreeMoney: "+fmt.Sprintf("%#v", this.FreeMoney)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Currency) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&order.Currency{")
	s = append(s, "Code: "+fmt.Sprintf("%#v", this.Code)+",\n")
	s = append(s, "ConvertedValue: "+fmt.Sprintf("%#v", this.ConvertedValue)+",\n")
	s = append(s, "Value: "+fmt.Sprintf("%#v", this.Value)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Position) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 15)
	s = append(s, "&order.Position{")
	s = append(s, "ConvertedPnl: "+fmt.Sprintf("%#v", this.ConvertedPnl)+",\n")
	s = append(s, "SymbolType: "+fmt.Sprintf("%#v", this.SymbolType)+",\n")
	s = append(s, "Currency: "+fmt.Sprintf("%#v", this.Currency)+",\n")
	s = append(s, "Id: "+fmt.Sprintf("%#v", this.Id)+",\n")
	s = append(s, "Pnl: "+fmt.Sprintf("%#v", this.Pnl)+",\n")
	s = append(s, "Price: "+fmt.Sprintf("%#v", this.Price)+",\n")
	s = append(s, "Quantity: "+fmt.Sprintf("%#v", this.Quantity)+",\n")
	s = append(s, "SymbolId: "+fmt.Sprintf("%#v", this.SymbolId)+",\n")
	s = append(s, "ConvertedValue: "+fmt.Sprintf("%#v", this.ConvertedValue)+",\n")
	s = append(s, "AveragePrice: "+fmt.Sprintf("%#v", this.AveragePrice)+",\n")
	s = append(s, "Value: "+fmt.Sprintf("%#v", this.Value)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TotalPosition) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 11)
	s = append(s, "&order.TotalPosition{")
	s = append(s, "Account: "+fmt.Sprintf("%#v", this.Account)+",\n")
	s = append(s, "LastUpdateTime: "+fmt.Sprintf("%#v", this.LastUpdateTime)+",\n")
	if this.Instrument != nil {
		s = append(s, "Instrument: "+fmt.Sprintf("%#v", this.Instrument)+",\n")
	}
	s = append(s, "RealizedPnl: "+fmt.Sprintf("%#v", this.RealizedPnl)+",\n")
	s = append(s, "DailyRealizedPnl: "+fmt.Sprintf("%#v", this.DailyRealizedPnl)+",\n")
	s = append(s, "Quantity: "+fmt.Sprintf("%#v", this.Quantity)+",\n")
	s = append(s, "AveragePrice: "+fmt.Sprintf("%#v", this.AveragePrice)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CalculatedPosition) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 12)
	s = append(s, "&order.CalculatedPosition{")
	s = append(s, "Account: "+fmt.Sprintf("%#v", this.Account)+",\n")
	s = append(s, "Strategy: "+fmt.Sprintf("%#v", this.Strategy)+",\n")
	if this.Instrument != nil {
		s = append(s, "Instrument: "+fmt.Sprintf("%#v", this.Instrument)+",\n")
	}
	s = append(s, "LastUpdateTime: "+fmt.Sprintf("%#v", this.LastUpdateTime)+",\n")
	s = append(s, "RealizedPnl: "+fmt.Sprintf("%#v", this.RealizedPnl)+",\n")
	s = append(s, "DailyRealizedPnl: "+fmt.Sprintf("%#v", this.DailyRealizedPnl)+",\n")
	s = append(s, "Quantity: "+fmt.Sprintf("%#v", this.Quantity)+",\n")
	s = append(s, "AveragePrice: "+fmt.Sprintf("%#v", this.AveragePrice)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GetPositionRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&order.GetPositionRequest{")
	s = append(s, "Account: "+fmt.Sprintf("%#v", this.Account)+",\n")
	s = append(s, "Strategy: "+fmt.Sprintf("%#v", this.Strategy)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GetPositionResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&order.GetPositionResponse{")
	if this.CalculatedPosition != nil {
		s = append(s, "CalculatedPosition: "+fmt.Sprintf("%#v", this.CalculatedPosition)+",\n")
	}
	if this.TotalPosition != nil {
		s = append(s, "TotalPosition: "+fmt.Sprintf("%#v", this.TotalPosition)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringOrder(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// OrderManagerClient is the client API for OrderManager service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type OrderManagerClient interface {
	GetOrderUpdate(ctx context.Context, in *GetOrderUpdateRequest, opts ...grpc.CallOption) (OrderManager_GetOrderUpdateClient, error)
}

type orderManagerClient struct {
	cc *grpc.ClientConn
}

func NewOrderManagerClient(cc *grpc.ClientConn) OrderManagerClient {
	return &orderManagerClient{cc}
}

func (c *orderManagerClient) GetOrderUpdate(ctx context.Context, in *GetOrderUpdateRequest, opts ...grpc.CallOption) (OrderManager_GetOrderUpdateClient, error) {
	stream, err := c.cc.NewStream(ctx, &_OrderManager_serviceDesc.Streams[0], "/order.OrderManager/GetOrderUpdate", opts...)
	if err != nil {
		return nil, err
	}
	x := &orderManagerGetOrderUpdateClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type OrderManager_GetOrderUpdateClient interface {
	Recv() (*GetOrderUpdateResponse, error)
	grpc.ClientStream
}

type orderManagerGetOrderUpdateClient struct {
	grpc.ClientStream
}

func (x *orderManagerGetOrderUpdateClient) Recv() (*GetOrderUpdateResponse, error) {
	m := new(GetOrderUpdateResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// OrderManagerServer is the server API for OrderManager service.
type OrderManagerServer interface {
	GetOrderUpdate(*GetOrderUpdateRequest, OrderManager_GetOrderUpdateServer) error
}

// UnimplementedOrderManagerServer can be embedded to have forward compatible implementations.
type UnimplementedOrderManagerServer struct {
}

func (*UnimplementedOrderManagerServer) GetOrderUpdate(req *GetOrderUpdateRequest, srv OrderManager_GetOrderUpdateServer) error {
	return status.Errorf(codes.Unimplemented, "method GetOrderUpdate not implemented")
}

func RegisterOrderManagerServer(s *grpc.Server, srv OrderManagerServer) {
	s.RegisterService(&_OrderManager_serviceDesc, srv)
}

func _OrderManager_GetOrderUpdate_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(GetOrderUpdateRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(OrderManagerServer).GetOrderUpdate(m, &orderManagerGetOrderUpdateServer{stream})
}

type OrderManager_GetOrderUpdateServer interface {
	Send(*GetOrderUpdateResponse) error
	grpc.ServerStream
}

type orderManagerGetOrderUpdateServer struct {
	grpc.ServerStream
}

func (x *orderManagerGetOrderUpdateServer) Send(m *GetOrderUpdateResponse) error {
	return x.ServerStream.SendMsg(m)
}

var _OrderManager_serviceDesc = grpc.ServiceDesc{
	ServiceName: "order.OrderManager",
	HandlerType: (*OrderManagerServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "GetOrderUpdate",
			Handler:       _OrderManager_GetOrderUpdate_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "app/business/entities/proto/order.proto",
}

func (m *GetOrderUpdateRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetOrderUpdateRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetOrderUpdateRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *GetOrderUpdateResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetOrderUpdateResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetOrderUpdateResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Order != nil {
		{
			size, err := m.Order.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintOrder(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Event) > 0 {
		i -= len(m.Event)
		copy(dAtA[i:], m.Event)
		i = encodeVarintOrder(dAtA, i, uint64(len(m.Event)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PlaceOrderRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PlaceOrderRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PlaceOrderRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.PartQuantity) > 0 {
		i -= len(m.PartQuantity)
		copy(dAtA[i:], m.PartQuantity)
		i = encodeVarintOrder(dAtA, i, uint64(len(m.PartQuantity)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x92
	}
	if len(m.PriceDistance) > 0 {
		i -= len(m.PriceDistance)
		copy(dAtA[i:], m.PriceDistance)
		i = encodeVarintOrder(dAtA, i, uint64(len(m.PriceDistance)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8a
	}
	if len(m.Account) > 0 {
		i -= len(m.Account)
		copy(dAtA[i:], m.Account)
		i = encodeVarintOrder(dAtA, i, uint64(len(m.Account)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	if len(m.GttExpiration) > 0 {
		i -= len(m.GttExpiration)
		copy(dAtA[i:], m.GttExpiration)
		i = encodeVarintOrder(dAtA, i, uint64(len(m.GttExpiration)))
		i--
		dAtA[i] = 0x7a
	}
	if len(m.LimitPrice) > 0 {
		i -= len(m.LimitPrice)
		copy(dAtA[i:], m.LimitPrice)
		i = encodeVarintOrder(dAtA, i, uint64(len(m.LimitPrice)))
		i--
		dAtA[i] = 0x72
	}
	if len(m.ClientTag) > 0 {
		i -= len(m.ClientTag)
		copy(dAtA[i:], m.ClientTag)
		i = encodeVarintOrder(dAtA, i, uint64(len(m.ClientTag)))
		i--
		dAtA[i] = 0x6a
	}
	if len(m.StopPrice) > 0 {
		i -= len(m.StopPrice)
		copy(dAtA[i:], m.StopPrice)
		i = encodeVarintOrder(dAtA, i, uint64(len(m.StopPrice)))
		i--
		dAtA[i] = 0x62
	}
	if len(m.TakeProfit) > 0 {
		i -= len(m.TakeProfit)
		copy(dAtA[i:], m.TakeProfit)
		i = encodeVarintOrder(dAtA, i, uint64(len(m.TakeProfit)))
		i--
		dAtA[i] = 0x5a
	}
	if len(m.OcoGroup) > 0 {
		i -= len(m.OcoGroup)
		copy(dAtA[i:], m.OcoGroup)
		i = encodeVarintOrder(dAtA, i, uint64(len(m.OcoGroup)))
		i--
		dAtA[i] = 0x52
	}
	if len(m.Duration) > 0 {
		i -= len(m.Duration)
		copy(dAtA[i:], m.Duration)
		i = encodeVarintOrder(dAtA, i, uint64(len(m.Duration)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.PlaceInterval) > 0 {
		i -= len(m.PlaceInterval)
		copy(dAtA[i:], m.PlaceInterval)
		i = encodeVarintOrder(dAtA, i, uint64(len(m.PlaceInterval)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.IdDoneParentId) > 0 {
		i -= len(m.IdDoneParentId)
		copy(dAtA[i:], m.IdDoneParentId)
		i = encodeVarintOrder(dAtA, i, uint64(len(m.IdDoneParentId)))
		i--
		dAtA[i] = 0x3a
	}
	if m.Side != 0 {
		i = encodeVarintOrder(dAtA, i, uint64(m.Side))
		i--
		dAtA[i] = 0x28
	}
	if m.Quantity != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Quantity))))
		i--
		dAtA[i] = 0x21
	}
	if len(m.StopLoss) > 0 {
		i -= len(m.StopLoss)
		copy(dAtA[i:], m.StopLoss)
		i = encodeVarintOrder(dAtA, i, uint64(len(m.StopLoss)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.OrderType) > 0 {
		i -= len(m.OrderType)
		copy(dAtA[i:], m.OrderType)
		i = encodeVarintOrder(dAtA, i, uint64(len(m.OrderType)))
		i--
		dAtA[i] = 0x12
	}
	if m.Instrument != nil {
		{
			size, err := m.Instrument.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintOrder(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Instrument) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Instrument) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Instrument) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Type) > 0 {
		i -= len(m.Type)
		copy(dAtA[i:], m.Type)
		i = encodeVarintOrder(dAtA, i, uint64(len(m.Type)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Symbol) > 0 {
		i -= len(m.Symbol)
		copy(dAtA[i:], m.Symbol)
		i = encodeVarintOrder(dAtA, i, uint64(len(m.Symbol)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintOrder(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PlaceOrderResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PlaceOrderResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PlaceOrderResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Orders) > 0 {
		for iNdEx := len(m.Orders) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Orders[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintOrder(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *OrderParameters) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OrderParameters) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OrderParameters) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.PartQuantity) > 0 {
		i -= len(m.PartQuantity)
		copy(dAtA[i:], m.PartQuantity)
		i = encodeVarintOrder(dAtA, i, uint64(len(m.PartQuantity)))
		i--
		dAtA[i] = 0x72
	}
	if len(m.PriceDistance) > 0 {
		i -= len(m.PriceDistance)
		copy(dAtA[i:], m.PriceDistance)
		i = encodeVarintOrder(dAtA, i, uint64(len(m.PriceDistance)))
		i--
		dAtA[i] = 0x6a
	}
	if len(m.OcoGroup) > 0 {
		i -= len(m.OcoGroup)
		copy(dAtA[i:], m.OcoGroup)
		i = encodeVarintOrder(dAtA, i, uint64(len(m.OcoGroup)))
		i--
		dAtA[i] = 0x62
	}
	if len(m.GttExpiration) > 0 {
		i -= len(m.GttExpiration)
		copy(dAtA[i:], m.GttExpiration)
		i = encodeVarintOrder(dAtA, i, uint64(len(m.GttExpiration)))
		i--
		dAtA[i] = 0x5a
	}
	if m.Quantity != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Quantity))))
		i--
		dAtA[i] = 0x51
	}
	if len(m.StopPrice) > 0 {
		i -= len(m.StopPrice)
		copy(dAtA[i:], m.StopPrice)
		i = encodeVarintOrder(dAtA, i, uint64(len(m.StopPrice)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.Duration) > 0 {
		i -= len(m.Duration)
		copy(dAtA[i:], m.Duration)
		i = encodeVarintOrder(dAtA, i, uint64(len(m.Duration)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.PlaceInterval) > 0 {
		i -= len(m.PlaceInterval)
		copy(dAtA[i:], m.PlaceInterval)
		i = encodeVarintOrder(dAtA, i, uint64(len(m.PlaceInterval)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.IfDoneParentId) > 0 {
		i -= len(m.IfDoneParentId)
		copy(dAtA[i:], m.IfDoneParentId)
		i = encodeVarintOrder(dAtA, i, uint64(len(m.IfDoneParentId)))
		i--
		dAtA[i] = 0x32
	}
	if m.Side != 0 {
		i = encodeVarintOrder(dAtA, i, uint64(m.Side))
		i--
		dAtA[i] = 0x20
	}
	if len(m.LimitPrice) > 0 {
		i -= len(m.LimitPrice)
		copy(dAtA[i:], m.LimitPrice)
		i = encodeVarintOrder(dAtA, i, uint64(len(m.LimitPrice)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.OrderType) > 0 {
		i -= len(m.OrderType)
		copy(dAtA[i:], m.OrderType)
		i = encodeVarintOrder(dAtA, i, uint64(len(m.OrderType)))
		i--
		dAtA[i] = 0x12
	}
	if m.Instrument != nil {
		{
			size, err := m.Instrument.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintOrder(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Order) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Order) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Order) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Account) > 0 {
		i -= len(m.Account)
		copy(dAtA[i:], m.Account)
		i = encodeVarintOrder(dAtA, i, uint64(len(m.Account)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.ClientTag) > 0 {
		i -= len(m.ClientTag)
		copy(dAtA[i:], m.ClientTag)
		i = encodeVarintOrder(dAtA, i, uint64(len(m.ClientTag)))
		i--
		dAtA[i] = 0x42
	}
	if m.OrderParameters != nil {
		{
			size, err := m.OrderParameters.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintOrder(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.OrderState != nil {
		{
			size, err := m.OrderState.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintOrder(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if len(m.OrderId) > 0 {
		i -= len(m.OrderId)
		copy(dAtA[i:], m.OrderId)
		i = encodeVarintOrder(dAtA, i, uint64(len(m.OrderId)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Username) > 0 {
		i -= len(m.Username)
		copy(dAtA[i:], m.Username)
		i = encodeVarintOrder(dAtA, i, uint64(len(m.Username)))
		i--
		dAtA[i] = 0x22
	}
	n6, err6 := github_com_gogo_protobuf_types.StdTimeMarshalTo(m.PlaceTime, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(m.PlaceTime):])
	if err6 != nil {
		return 0, err6
	}
	i -= n6
	i = encodeVarintOrder(dAtA, i, uint64(n6))
	i--
	dAtA[i] = 0x1a
	if len(m.CurrentModificationId) > 0 {
		i -= len(m.CurrentModificationId)
		copy(dAtA[i:], m.CurrentModificationId)
		i = encodeVarintOrder(dAtA, i, uint64(len(m.CurrentModificationId)))
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}

func (m *OrderState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OrderState) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OrderState) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Trades) > 0 {
		for iNdEx := len(m.Trades) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Trades[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintOrder(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Reason) > 0 {
		i -= len(m.Reason)
		copy(dAtA[i:], m.Reason)
		i = encodeVarintOrder(dAtA, i, uint64(len(m.Reason)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Status != 0 {
		i = encodeVarintOrder(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x10
	}
	n7, err7 := github_com_gogo_protobuf_types.StdTimeMarshalTo(m.LastUpdateTime, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(m.LastUpdateTime):])
	if err7 != nil {
		return 0, err7
	}
	i -= n7
	i = encodeVarintOrder(dAtA, i, uint64(n7))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *Trade) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Trade) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Trade) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Price != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Price))))
		i--
		dAtA[i] = 0x29
	}
	if m.Position != 0 {
		i = encodeVarintOrder(dAtA, i, uint64(m.Position))
		i--
		dAtA[i] = 0x18
	}
	if m.Quantity != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Quantity))))
		i--
		dAtA[i] = 0x11
	}
	n8, err8 := github_com_gogo_protobuf_types.StdTimeMarshalTo(m.Time, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(m.Time):])
	if err8 != nil {
		return 0, err8
	}
	i -= n8
	i = encodeVarintOrder(dAtA, i, uint64(n8))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *GetAccountSummaryRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetAccountSummaryRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetAccountSummaryRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Currency) > 0 {
		i -= len(m.Currency)
		copy(dAtA[i:], m.Currency)
		i = encodeVarintOrder(dAtA, i, uint64(len(m.Currency)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Account) > 0 {
		i -= len(m.Account)
		copy(dAtA[i:], m.Account)
		i = encodeVarintOrder(dAtA, i, uint64(len(m.Account)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetAccountSummaryResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetAccountSummaryResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetAccountSummaryResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.AccountSummary != nil {
		{
			size, err := m.AccountSummary.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintOrder(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AccountSummary) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AccountSummary) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AccountSummary) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.FreeMoney) > 0 {
		i -= len(m.FreeMoney)
		copy(dAtA[i:], m.FreeMoney)
		i = encodeVarintOrder(dAtA, i, uint64(len(m.FreeMoney)))
		i--
		dAtA[i] = 0x52
	}
	if len(m.SessionDate) > 0 {
		i -= len(m.SessionDate)
		copy(dAtA[i:], m.SessionDate)
		i = encodeVarintOrder(dAtA, i, uint64(len(m.SessionDate)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.Account) > 0 {
		i -= len(m.Account)
		copy(dAtA[i:], m.Account)
		i = encodeVarintOrder(dAtA, i, uint64(len(m.Account)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.Currencies) > 0 {
		for iNdEx := len(m.Currencies) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Currencies[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintOrder(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.MoneyUsedForMargin) > 0 {
		i -= len(m.MoneyUsedForMargin)
		copy(dAtA[i:], m.MoneyUsedForMargin)
		i = encodeVarintOrder(dAtA, i, uint64(len(m.MoneyUsedForMargin)))
		i--
		dAtA[i] = 0x32
	}
	n10, err10 := github_com_gogo_protobuf_types.StdTimeMarshalTo(m.Timestamp, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(m.Timestamp):])
	if err10 != nil {
		return 0, err10
	}
	i -= n10
	i = encodeVarintOrder(dAtA, i, uint64(n10))
	i--
	dAtA[i] = 0x2a
	if len(m.MarginUtilization) > 0 {
		i -= len(m.MarginUtilization)
		copy(dAtA[i:], m.MarginUtilization)
		i = encodeVarintOrder(dAtA, i, uint64(len(m.MarginUtilization)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Currency) > 0 {
		i -= len(m.Currency)
		copy(dAtA[i:], m.Currency)
		i = encodeVarintOrder(dAtA, i, uint64(len(m.Currency)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Positions) > 0 {
		for iNdEx := len(m.Positions) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Positions[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintOrder(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.NetAssetValue) > 0 {
		i -= len(m.NetAssetValue)
		copy(dAtA[i:], m.NetAssetValue)
		i = encodeVarintOrder(dAtA, i, uint64(len(m.NetAssetValue)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Currency) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Currency) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Currency) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintOrder(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ConvertedValue) > 0 {
		i -= len(m.ConvertedValue)
		copy(dAtA[i:], m.ConvertedValue)
		i = encodeVarintOrder(dAtA, i, uint64(len(m.ConvertedValue)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Code) > 0 {
		i -= len(m.Code)
		copy(dAtA[i:], m.Code)
		i = encodeVarintOrder(dAtA, i, uint64(len(m.Code)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Position) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Position) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Position) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintOrder(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0x5a
	}
	if len(m.AveragePrice) > 0 {
		i -= len(m.AveragePrice)
		copy(dAtA[i:], m.AveragePrice)
		i = encodeVarintOrder(dAtA, i, uint64(len(m.AveragePrice)))
		i--
		dAtA[i] = 0x52
	}
	if len(m.ConvertedValue) > 0 {
		i -= len(m.ConvertedValue)
		copy(dAtA[i:], m.ConvertedValue)
		i = encodeVarintOrder(dAtA, i, uint64(len(m.ConvertedValue)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.SymbolId) > 0 {
		i -= len(m.SymbolId)
		copy(dAtA[i:], m.SymbolId)
		i = encodeVarintOrder(dAtA, i, uint64(len(m.SymbolId)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.Quantity) > 0 {
		i -= len(m.Quantity)
		copy(dAtA[i:], m.Quantity)
		i = encodeVarintOrder(dAtA, i, uint64(len(m.Quantity)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.Price) > 0 {
		i -= len(m.Price)
		copy(dAtA[i:], m.Price)
		i = encodeVarintOrder(dAtA, i, uint64(len(m.Price)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Pnl) > 0 {
		i -= len(m.Pnl)
		copy(dAtA[i:], m.Pnl)
		i = encodeVarintOrder(dAtA, i, uint64(len(m.Pnl)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintOrder(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Currency) > 0 {
		i -= len(m.Currency)
		copy(dAtA[i:], m.Currency)
		i = encodeVarintOrder(dAtA, i, uint64(len(m.Currency)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.SymbolType) > 0 {
		i -= len(m.SymbolType)
		copy(dAtA[i:], m.SymbolType)
		i = encodeVarintOrder(dAtA, i, uint64(len(m.SymbolType)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ConvertedPnl) > 0 {
		i -= len(m.ConvertedPnl)
		copy(dAtA[i:], m.ConvertedPnl)
		i = encodeVarintOrder(dAtA, i, uint64(len(m.ConvertedPnl)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TotalPosition) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TotalPosition) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TotalPosition) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DailyRealizedPnl != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.DailyRealizedPnl))))
		i--
		dAtA[i] = 0x79
	}
	if m.RealizedPnl != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.RealizedPnl))))
		i--
		dAtA[i] = 0x71
	}
	if len(m.Account) > 0 {
		i -= len(m.Account)
		copy(dAtA[i:], m.Account)
		i = encodeVarintOrder(dAtA, i, uint64(len(m.Account)))
		i--
		dAtA[i] = 0x62
	}
	if m.AveragePrice != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.AveragePrice))))
		i--
		dAtA[i] = 0x51
	}
	n11, err11 := github_com_gogo_protobuf_types.StdTimeMarshalTo(m.LastUpdateTime, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(m.LastUpdateTime):])
	if err11 != nil {
		return 0, err11
	}
	i -= n11
	i = encodeVarintOrder(dAtA, i, uint64(n11))
	i--
	dAtA[i] = 0x42
	if m.Quantity != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Quantity))))
		i--
		dAtA[i] = 0x39
	}
	if m.Instrument != nil {
		{
			size, err := m.Instrument.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintOrder(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}

func (m *CalculatedPosition) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CalculatedPosition) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CalculatedPosition) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DailyRealizedPnl != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.DailyRealizedPnl))))
		i--
		dAtA[i] = 0x79
	}
	if m.RealizedPnl != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.RealizedPnl))))
		i--
		dAtA[i] = 0x71
	}
	if len(m.Strategy) > 0 {
		i -= len(m.Strategy)
		copy(dAtA[i:], m.Strategy)
		i = encodeVarintOrder(dAtA, i, uint64(len(m.Strategy)))
		i--
		dAtA[i] = 0x6a
	}
	if len(m.Account) > 0 {
		i -= len(m.Account)
		copy(dAtA[i:], m.Account)
		i = encodeVarintOrder(dAtA, i, uint64(len(m.Account)))
		i--
		dAtA[i] = 0x62
	}
	if m.AveragePrice != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.AveragePrice))))
		i--
		dAtA[i] = 0x51
	}
	n13, err13 := github_com_gogo_protobuf_types.StdTimeMarshalTo(m.LastUpdateTime, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(m.LastUpdateTime):])
	if err13 != nil {
		return 0, err13
	}
	i -= n13
	i = encodeVarintOrder(dAtA, i, uint64(n13))
	i--
	dAtA[i] = 0x42
	if m.Quantity != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Quantity))))
		i--
		dAtA[i] = 0x39
	}
	if m.Instrument != nil {
		{
			size, err := m.Instrument.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintOrder(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}

func (m *GetPositionRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetPositionRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetPositionRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Strategy) > 0 {
		i -= len(m.Strategy)
		copy(dAtA[i:], m.Strategy)
		i = encodeVarintOrder(dAtA, i, uint64(len(m.Strategy)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Account) > 0 {
		i -= len(m.Account)
		copy(dAtA[i:], m.Account)
		i = encodeVarintOrder(dAtA, i, uint64(len(m.Account)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetPositionResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetPositionResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetPositionResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TotalPosition != nil {
		{
			size, err := m.TotalPosition.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintOrder(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.CalculatedPosition != nil {
		{
			size, err := m.CalculatedPosition.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintOrder(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintOrder(dAtA []byte, offset int, v uint64) int {
	offset -= sovOrder(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func NewPopulatedGetOrderUpdateRequest(r randyOrder, easy bool) *GetOrderUpdateRequest {
	this := &GetOrderUpdateRequest{}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedGetOrderUpdateResponse(r randyOrder, easy bool) *GetOrderUpdateResponse {
	this := &GetOrderUpdateResponse{}
	this.Event = string(randStringOrder(r))
	if r.Intn(5) != 0 {
		this.Order = NewPopulatedOrder(r, easy)
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedPlaceOrderRequest(r randyOrder, easy bool) *PlaceOrderRequest {
	this := &PlaceOrderRequest{}
	if r.Intn(5) != 0 {
		this.Instrument = NewPopulatedInstrument(r, easy)
	}
	this.OrderType = string(randStringOrder(r))
	this.StopLoss = string(randStringOrder(r))
	this.Quantity = float64(r.Float64())
	if r.Intn(2) == 0 {
		this.Quantity *= -1
	}
	this.Side = Side([]int32{0, 1}[r.Intn(2)])
	this.IdDoneParentId = string(randStringOrder(r))
	this.PlaceInterval = string(randStringOrder(r))
	this.Duration = string(randStringOrder(r))
	this.OcoGroup = string(randStringOrder(r))
	this.TakeProfit = string(randStringOrder(r))
	this.StopPrice = string(randStringOrder(r))
	this.ClientTag = string(randStringOrder(r))
	this.LimitPrice = string(randStringOrder(r))
	this.GttExpiration = string(randStringOrder(r))
	this.Account = string(randStringOrder(r))
	this.PriceDistance = string(randStringOrder(r))
	this.PartQuantity = string(randStringOrder(r))
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedInstrument(r randyOrder, easy bool) *Instrument {
	this := &Instrument{}
	this.Id = string(randStringOrder(r))
	this.Symbol = string(randStringOrder(r))
	this.Type = string(randStringOrder(r))
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedPlaceOrderResponse(r randyOrder, easy bool) *PlaceOrderResponse {
	this := &PlaceOrderResponse{}
	if r.Intn(5) != 0 {
		v1 := r.Intn(5)
		this.Orders = make([]*Order, v1)
		for i := 0; i < v1; i++ {
			this.Orders[i] = NewPopulatedOrder(r, easy)
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedOrderParameters(r randyOrder, easy bool) *OrderParameters {
	this := &OrderParameters{}
	if r.Intn(5) != 0 {
		this.Instrument = NewPopulatedInstrument(r, easy)
	}
	this.OrderType = string(randStringOrder(r))
	this.LimitPrice = string(randStringOrder(r))
	this.Side = Side([]int32{0, 1}[r.Intn(2)])
	this.IfDoneParentId = string(randStringOrder(r))
	this.PlaceInterval = string(randStringOrder(r))
	this.Duration = string(randStringOrder(r))
	this.StopPrice = string(randStringOrder(r))
	this.Quantity = float64(r.Float64())
	if r.Intn(2) == 0 {
		this.Quantity *= -1
	}
	this.GttExpiration = string(randStringOrder(r))
	this.OcoGroup = string(randStringOrder(r))
	this.PriceDistance = string(randStringOrder(r))
	this.PartQuantity = string(randStringOrder(r))
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedOrder(r randyOrder, easy bool) *Order {
	this := &Order{}
	this.CurrentModificationId = string(randStringOrder(r))
	v2 := github_com_gogo_protobuf_types.NewPopulatedStdTime(r, easy)
	this.PlaceTime = *v2
	this.Username = string(randStringOrder(r))
	this.OrderId = string(randStringOrder(r))
	if r.Intn(5) != 0 {
		this.OrderState = NewPopulatedOrderState(r, easy)
	}
	if r.Intn(5) != 0 {
		this.OrderParameters = NewPopulatedOrderParameters(r, easy)
	}
	this.ClientTag = string(randStringOrder(r))
	this.Account = string(randStringOrder(r))
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedOrderState(r randyOrder, easy bool) *OrderState {
	this := &OrderState{}
	v3 := github_com_gogo_protobuf_types.NewPopulatedStdTime(r, easy)
	this.LastUpdateTime = *v3
	this.Status = Status([]int32{0, 1, 2, 3, 4, 5}[r.Intn(6)])
	this.Reason = string(randStringOrder(r))
	if r.Intn(5) != 0 {
		v4 := r.Intn(5)
		this.Trades = make([]Trade, v4)
		for i := 0; i < v4; i++ {
			v5 := NewPopulatedTrade(r, easy)
			this.Trades[i] = *v5
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedTrade(r randyOrder, easy bool) *Trade {
	this := &Trade{}
	v6 := github_com_gogo_protobuf_types.NewPopulatedStdTime(r, easy)
	this.Time = *v6
	this.Quantity = float64(r.Float64())
	if r.Intn(2) == 0 {
		this.Quantity *= -1
	}
	this.Position = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.Position *= -1
	}
	this.Price = float64(r.Float64())
	if r.Intn(2) == 0 {
		this.Price *= -1
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedGetAccountSummaryRequest(r randyOrder, easy bool) *GetAccountSummaryRequest {
	this := &GetAccountSummaryRequest{}
	this.Account = string(randStringOrder(r))
	this.Currency = string(randStringOrder(r))
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedGetAccountSummaryResponse(r randyOrder, easy bool) *GetAccountSummaryResponse {
	this := &GetAccountSummaryResponse{}
	if r.Intn(5) != 0 {
		this.AccountSummary = NewPopulatedAccountSummary(r, easy)
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedAccountSummary(r randyOrder, easy bool) *AccountSummary {
	this := &AccountSummary{}
	this.NetAssetValue = string(randStringOrder(r))
	if r.Intn(5) != 0 {
		v7 := r.Intn(5)
		this.Positions = make([]*Position, v7)
		for i := 0; i < v7; i++ {
			this.Positions[i] = NewPopulatedPosition(r, easy)
		}
	}
	this.Currency = string(randStringOrder(r))
	this.MarginUtilization = string(randStringOrder(r))
	v8 := github_com_gogo_protobuf_types.NewPopulatedStdTime(r, easy)
	this.Timestamp = *v8
	this.MoneyUsedForMargin = string(randStringOrder(r))
	if r.Intn(5) != 0 {
		v9 := r.Intn(5)
		this.Currencies = make([]*Currency, v9)
		for i := 0; i < v9; i++ {
			this.Currencies[i] = NewPopulatedCurrency(r, easy)
		}
	}
	this.Account = string(randStringOrder(r))
	this.SessionDate = string(randStringOrder(r))
	this.FreeMoney = string(randStringOrder(r))
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedCurrency(r randyOrder, easy bool) *Currency {
	this := &Currency{}
	this.Code = string(randStringOrder(r))
	this.ConvertedValue = string(randStringOrder(r))
	this.Value = string(randStringOrder(r))
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedPosition(r randyOrder, easy bool) *Position {
	this := &Position{}
	this.ConvertedPnl = string(randStringOrder(r))
	this.SymbolType = string(randStringOrder(r))
	this.Currency = string(randStringOrder(r))
	this.Id = string(randStringOrder(r))
	this.Pnl = string(randStringOrder(r))
	this.Price = string(randStringOrder(r))
	this.Quantity = string(randStringOrder(r))
	this.SymbolId = string(randStringOrder(r))
	this.ConvertedValue = string(randStringOrder(r))
	this.AveragePrice = string(randStringOrder(r))
	this.Value = string(randStringOrder(r))
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedTotalPosition(r randyOrder, easy bool) *TotalPosition {
	this := &TotalPosition{}
	if r.Intn(5) != 0 {
		this.Instrument = NewPopulatedInstrument(r, easy)
	}
	this.Quantity = float64(r.Float64())
	if r.Intn(2) == 0 {
		this.Quantity *= -1
	}
	v10 := github_com_gogo_protobuf_types.NewPopulatedStdTime(r, easy)
	this.LastUpdateTime = *v10
	this.AveragePrice = float64(r.Float64())
	if r.Intn(2) == 0 {
		this.AveragePrice *= -1
	}
	this.Account = string(randStringOrder(r))
	this.RealizedPnl = float64(r.Float64())
	if r.Intn(2) == 0 {
		this.RealizedPnl *= -1
	}
	this.DailyRealizedPnl = float64(r.Float64())
	if r.Intn(2) == 0 {
		this.DailyRealizedPnl *= -1
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedCalculatedPosition(r randyOrder, easy bool) *CalculatedPosition {
	this := &CalculatedPosition{}
	if r.Intn(5) != 0 {
		this.Instrument = NewPopulatedInstrument(r, easy)
	}
	this.Quantity = float64(r.Float64())
	if r.Intn(2) == 0 {
		this.Quantity *= -1
	}
	v11 := github_com_gogo_protobuf_types.NewPopulatedStdTime(r, easy)
	this.LastUpdateTime = *v11
	this.AveragePrice = float64(r.Float64())
	if r.Intn(2) == 0 {
		this.AveragePrice *= -1
	}
	this.Account = string(randStringOrder(r))
	this.Strategy = string(randStringOrder(r))
	this.RealizedPnl = float64(r.Float64())
	if r.Intn(2) == 0 {
		this.RealizedPnl *= -1
	}
	this.DailyRealizedPnl = float64(r.Float64())
	if r.Intn(2) == 0 {
		this.DailyRealizedPnl *= -1
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedGetPositionRequest(r randyOrder, easy bool) *GetPositionRequest {
	this := &GetPositionRequest{}
	this.Account = string(randStringOrder(r))
	this.Strategy = string(randStringOrder(r))
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedGetPositionResponse(r randyOrder, easy bool) *GetPositionResponse {
	this := &GetPositionResponse{}
	if r.Intn(5) != 0 {
		this.CalculatedPosition = NewPopulatedCalculatedPosition(r, easy)
	}
	if r.Intn(5) != 0 {
		this.TotalPosition = NewPopulatedTotalPosition(r, easy)
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

type randyOrder interface {
	Float32() float32
	Float64() float64
	Int63() int64
	Int31() int32
	Uint32() uint32
	Intn(n int) int
}

func randUTF8RuneOrder(r randyOrder) rune {
	ru := r.Intn(62)
	if ru < 10 {
		return rune(ru + 48)
	} else if ru < 36 {
		return rune(ru + 55)
	}
	return rune(ru + 61)
}
func randStringOrder(r randyOrder) string {
	v12 := r.Intn(100)
	tmps := make([]rune, v12)
	for i := 0; i < v12; i++ {
		tmps[i] = randUTF8RuneOrder(r)
	}
	return string(tmps)
}
func randUnrecognizedOrder(r randyOrder, maxFieldNumber int) (dAtA []byte) {
	l := r.Intn(5)
	for i := 0; i < l; i++ {
		wire := r.Intn(4)
		if wire == 3 {
			wire = 5
		}
		fieldNumber := maxFieldNumber + r.Intn(100)
		dAtA = randFieldOrder(dAtA, r, fieldNumber, wire)
	}
	return dAtA
}
func randFieldOrder(dAtA []byte, r randyOrder, fieldNumber int, wire int) []byte {
	key := uint32(fieldNumber)<<3 | uint32(wire)
	switch wire {
	case 0:
		dAtA = encodeVarintPopulateOrder(dAtA, uint64(key))
		v13 := r.Int63()
		if r.Intn(2) == 0 {
			v13 *= -1
		}
		dAtA = encodeVarintPopulateOrder(dAtA, uint64(v13))
	case 1:
		dAtA = encodeVarintPopulateOrder(dAtA, uint64(key))
		dAtA = append(dAtA, byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)))
	case 2:
		dAtA = encodeVarintPopulateOrder(dAtA, uint64(key))
		ll := r.Intn(100)
		dAtA = encodeVarintPopulateOrder(dAtA, uint64(ll))
		for j := 0; j < ll; j++ {
			dAtA = append(dAtA, byte(r.Intn(256)))
		}
	default:
		dAtA = encodeVarintPopulateOrder(dAtA, uint64(key))
		dAtA = append(dAtA, byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)))
	}
	return dAtA
}
func encodeVarintPopulateOrder(dAtA []byte, v uint64) []byte {
	for v >= 1<<7 {
		dAtA = append(dAtA, uint8(uint64(v)&0x7f|0x80))
		v >>= 7
	}
	dAtA = append(dAtA, uint8(v))
	return dAtA
}
func (m *GetOrderUpdateRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *GetOrderUpdateResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Event)
	if l > 0 {
		n += 1 + l + sovOrder(uint64(l))
	}
	if m.Order != nil {
		l = m.Order.Size()
		n += 1 + l + sovOrder(uint64(l))
	}
	return n
}

func (m *PlaceOrderRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Instrument != nil {
		l = m.Instrument.Size()
		n += 1 + l + sovOrder(uint64(l))
	}
	l = len(m.OrderType)
	if l > 0 {
		n += 1 + l + sovOrder(uint64(l))
	}
	l = len(m.StopLoss)
	if l > 0 {
		n += 1 + l + sovOrder(uint64(l))
	}
	if m.Quantity != 0 {
		n += 9
	}
	if m.Side != 0 {
		n += 1 + sovOrder(uint64(m.Side))
	}
	l = len(m.IdDoneParentId)
	if l > 0 {
		n += 1 + l + sovOrder(uint64(l))
	}
	l = len(m.PlaceInterval)
	if l > 0 {
		n += 1 + l + sovOrder(uint64(l))
	}
	l = len(m.Duration)
	if l > 0 {
		n += 1 + l + sovOrder(uint64(l))
	}
	l = len(m.OcoGroup)
	if l > 0 {
		n += 1 + l + sovOrder(uint64(l))
	}
	l = len(m.TakeProfit)
	if l > 0 {
		n += 1 + l + sovOrder(uint64(l))
	}
	l = len(m.StopPrice)
	if l > 0 {
		n += 1 + l + sovOrder(uint64(l))
	}
	l = len(m.ClientTag)
	if l > 0 {
		n += 1 + l + sovOrder(uint64(l))
	}
	l = len(m.LimitPrice)
	if l > 0 {
		n += 1 + l + sovOrder(uint64(l))
	}
	l = len(m.GttExpiration)
	if l > 0 {
		n += 1 + l + sovOrder(uint64(l))
	}
	l = len(m.Account)
	if l > 0 {
		n += 2 + l + sovOrder(uint64(l))
	}
	l = len(m.PriceDistance)
	if l > 0 {
		n += 2 + l + sovOrder(uint64(l))
	}
	l = len(m.PartQuantity)
	if l > 0 {
		n += 2 + l + sovOrder(uint64(l))
	}
	return n
}

func (m *Instrument) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovOrder(uint64(l))
	}
	l = len(m.Symbol)
	if l > 0 {
		n += 1 + l + sovOrder(uint64(l))
	}
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovOrder(uint64(l))
	}
	return n
}

func (m *PlaceOrderResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Orders) > 0 {
		for _, e := range m.Orders {
			l = e.Size()
			n += 1 + l + sovOrder(uint64(l))
		}
	}
	return n
}

func (m *OrderParameters) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Instrument != nil {
		l = m.Instrument.Size()
		n += 1 + l + sovOrder(uint64(l))
	}
	l = len(m.OrderType)
	if l > 0 {
		n += 1 + l + sovOrder(uint64(l))
	}
	l = len(m.LimitPrice)
	if l > 0 {
		n += 1 + l + sovOrder(uint64(l))
	}
	if m.Side != 0 {
		n += 1 + sovOrder(uint64(m.Side))
	}
	l = len(m.IfDoneParentId)
	if l > 0 {
		n += 1 + l + sovOrder(uint64(l))
	}
	l = len(m.PlaceInterval)
	if l > 0 {
		n += 1 + l + sovOrder(uint64(l))
	}
	l = len(m.Duration)
	if l > 0 {
		n += 1 + l + sovOrder(uint64(l))
	}
	l = len(m.StopPrice)
	if l > 0 {
		n += 1 + l + sovOrder(uint64(l))
	}
	if m.Quantity != 0 {
		n += 9
	}
	l = len(m.GttExpiration)
	if l > 0 {
		n += 1 + l + sovOrder(uint64(l))
	}
	l = len(m.OcoGroup)
	if l > 0 {
		n += 1 + l + sovOrder(uint64(l))
	}
	l = len(m.PriceDistance)
	if l > 0 {
		n += 1 + l + sovOrder(uint64(l))
	}
	l = len(m.PartQuantity)
	if l > 0 {
		n += 1 + l + sovOrder(uint64(l))
	}
	return n
}

func (m *Order) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.CurrentModificationId)
	if l > 0 {
		n += 1 + l + sovOrder(uint64(l))
	}
	l = github_com_gogo_protobuf_types.SizeOfStdTime(m.PlaceTime)
	n += 1 + l + sovOrder(uint64(l))
	l = len(m.Username)
	if l > 0 {
		n += 1 + l + sovOrder(uint64(l))
	}
	l = len(m.OrderId)
	if l > 0 {
		n += 1 + l + sovOrder(uint64(l))
	}
	if m.OrderState != nil {
		l = m.OrderState.Size()
		n += 1 + l + sovOrder(uint64(l))
	}
	if m.OrderParameters != nil {
		l = m.OrderParameters.Size()
		n += 1 + l + sovOrder(uint64(l))
	}
	l = len(m.ClientTag)
	if l > 0 {
		n += 1 + l + sovOrder(uint64(l))
	}
	l = len(m.Account)
	if l > 0 {
		n += 1 + l + sovOrder(uint64(l))
	}
	return n
}

func (m *OrderState) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = github_com_gogo_protobuf_types.SizeOfStdTime(m.LastUpdateTime)
	n += 1 + l + sovOrder(uint64(l))
	if m.Status != 0 {
		n += 1 + sovOrder(uint64(m.Status))
	}
	l = len(m.Reason)
	if l > 0 {
		n += 1 + l + sovOrder(uint64(l))
	}
	if len(m.Trades) > 0 {
		for _, e := range m.Trades {
			l = e.Size()
			n += 1 + l + sovOrder(uint64(l))
		}
	}
	return n
}

func (m *Trade) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = github_com_gogo_protobuf_types.SizeOfStdTime(m.Time)
	n += 1 + l + sovOrder(uint64(l))
	if m.Quantity != 0 {
		n += 9
	}
	if m.Position != 0 {
		n += 1 + sovOrder(uint64(m.Position))
	}
	if m.Price != 0 {
		n += 9
	}
	return n
}

func (m *GetAccountSummaryRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Account)
	if l > 0 {
		n += 1 + l + sovOrder(uint64(l))
	}
	l = len(m.Currency)
	if l > 0 {
		n += 1 + l + sovOrder(uint64(l))
	}
	return n
}

func (m *GetAccountSummaryResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AccountSummary != nil {
		l = m.AccountSummary.Size()
		n += 1 + l + sovOrder(uint64(l))
	}
	return n
}

func (m *AccountSummary) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.NetAssetValue)
	if l > 0 {
		n += 1 + l + sovOrder(uint64(l))
	}
	if len(m.Positions) > 0 {
		for _, e := range m.Positions {
			l = e.Size()
			n += 1 + l + sovOrder(uint64(l))
		}
	}
	l = len(m.Currency)
	if l > 0 {
		n += 1 + l + sovOrder(uint64(l))
	}
	l = len(m.MarginUtilization)
	if l > 0 {
		n += 1 + l + sovOrder(uint64(l))
	}
	l = github_com_gogo_protobuf_types.SizeOfStdTime(m.Timestamp)
	n += 1 + l + sovOrder(uint64(l))
	l = len(m.MoneyUsedForMargin)
	if l > 0 {
		n += 1 + l + sovOrder(uint64(l))
	}
	if len(m.Currencies) > 0 {
		for _, e := range m.Currencies {
			l = e.Size()
			n += 1 + l + sovOrder(uint64(l))
		}
	}
	l = len(m.Account)
	if l > 0 {
		n += 1 + l + sovOrder(uint64(l))
	}
	l = len(m.SessionDate)
	if l > 0 {
		n += 1 + l + sovOrder(uint64(l))
	}
	l = len(m.FreeMoney)
	if l > 0 {
		n += 1 + l + sovOrder(uint64(l))
	}
	return n
}

func (m *Currency) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Code)
	if l > 0 {
		n += 1 + l + sovOrder(uint64(l))
	}
	l = len(m.ConvertedValue)
	if l > 0 {
		n += 1 + l + sovOrder(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovOrder(uint64(l))
	}
	return n
}

func (m *Position) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ConvertedPnl)
	if l > 0 {
		n += 1 + l + sovOrder(uint64(l))
	}
	l = len(m.SymbolType)
	if l > 0 {
		n += 1 + l + sovOrder(uint64(l))
	}
	l = len(m.Currency)
	if l > 0 {
		n += 1 + l + sovOrder(uint64(l))
	}
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovOrder(uint64(l))
	}
	l = len(m.Pnl)
	if l > 0 {
		n += 1 + l + sovOrder(uint64(l))
	}
	l = len(m.Price)
	if l > 0 {
		n += 1 + l + sovOrder(uint64(l))
	}
	l = len(m.Quantity)
	if l > 0 {
		n += 1 + l + sovOrder(uint64(l))
	}
	l = len(m.SymbolId)
	if l > 0 {
		n += 1 + l + sovOrder(uint64(l))
	}
	l = len(m.ConvertedValue)
	if l > 0 {
		n += 1 + l + sovOrder(uint64(l))
	}
	l = len(m.AveragePrice)
	if l > 0 {
		n += 1 + l + sovOrder(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovOrder(uint64(l))
	}
	return n
}

func (m *TotalPosition) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Instrument != nil {
		l = m.Instrument.Size()
		n += 1 + l + sovOrder(uint64(l))
	}
	if m.Quantity != 0 {
		n += 9
	}
	l = github_com_gogo_protobuf_types.SizeOfStdTime(m.LastUpdateTime)
	n += 1 + l + sovOrder(uint64(l))
	if m.AveragePrice != 0 {
		n += 9
	}
	l = len(m.Account)
	if l > 0 {
		n += 1 + l + sovOrder(uint64(l))
	}
	if m.RealizedPnl != 0 {
		n += 9
	}
	if m.DailyRealizedPnl != 0 {
		n += 9
	}
	return n
}

func (m *CalculatedPosition) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Instrument != nil {
		l = m.Instrument.Size()
		n += 1 + l + sovOrder(uint64(l))
	}
	if m.Quantity != 0 {
		n += 9
	}
	l = github_com_gogo_protobuf_types.SizeOfStdTime(m.LastUpdateTime)
	n += 1 + l + sovOrder(uint64(l))
	if m.AveragePrice != 0 {
		n += 9
	}
	l = len(m.Account)
	if l > 0 {
		n += 1 + l + sovOrder(uint64(l))
	}
	l = len(m.Strategy)
	if l > 0 {
		n += 1 + l + sovOrder(uint64(l))
	}
	if m.RealizedPnl != 0 {
		n += 9
	}
	if m.DailyRealizedPnl != 0 {
		n += 9
	}
	return n
}

func (m *GetPositionRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Account)
	if l > 0 {
		n += 1 + l + sovOrder(uint64(l))
	}
	l = len(m.Strategy)
	if l > 0 {
		n += 1 + l + sovOrder(uint64(l))
	}
	return n
}

func (m *GetPositionResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CalculatedPosition != nil {
		l = m.CalculatedPosition.Size()
		n += 1 + l + sovOrder(uint64(l))
	}
	if m.TotalPosition != nil {
		l = m.TotalPosition.Size()
		n += 1 + l + sovOrder(uint64(l))
	}
	return n
}

func sovOrder(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozOrder(x uint64) (n int) {
	return sovOrder(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *GetOrderUpdateRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetOrderUpdateRequest{`,
		`}`,
	}, "")
	return s
}
func (this *GetOrderUpdateResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetOrderUpdateResponse{`,
		`Event:` + fmt.Sprintf("%v", this.Event) + `,`,
		`Order:` + strings.Replace(this.Order.String(), "Order", "Order", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PlaceOrderRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PlaceOrderRequest{`,
		`Instrument:` + strings.Replace(this.Instrument.String(), "Instrument", "Instrument", 1) + `,`,
		`OrderType:` + fmt.Sprintf("%v", this.OrderType) + `,`,
		`StopLoss:` + fmt.Sprintf("%v", this.StopLoss) + `,`,
		`Quantity:` + fmt.Sprintf("%v", this.Quantity) + `,`,
		`Side:` + fmt.Sprintf("%v", this.Side) + `,`,
		`IdDoneParentId:` + fmt.Sprintf("%v", this.IdDoneParentId) + `,`,
		`PlaceInterval:` + fmt.Sprintf("%v", this.PlaceInterval) + `,`,
		`Duration:` + fmt.Sprintf("%v", this.Duration) + `,`,
		`OcoGroup:` + fmt.Sprintf("%v", this.OcoGroup) + `,`,
		`TakeProfit:` + fmt.Sprintf("%v", this.TakeProfit) + `,`,
		`StopPrice:` + fmt.Sprintf("%v", this.StopPrice) + `,`,
		`ClientTag:` + fmt.Sprintf("%v", this.ClientTag) + `,`,
		`LimitPrice:` + fmt.Sprintf("%v", this.LimitPrice) + `,`,
		`GttExpiration:` + fmt.Sprintf("%v", this.GttExpiration) + `,`,
		`Account:` + fmt.Sprintf("%v", this.Account) + `,`,
		`PriceDistance:` + fmt.Sprintf("%v", this.PriceDistance) + `,`,
		`PartQuantity:` + fmt.Sprintf("%v", this.PartQuantity) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Instrument) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Instrument{`,
		`Id:` + fmt.Sprintf("%v", this.Id) + `,`,
		`Symbol:` + fmt.Sprintf("%v", this.Symbol) + `,`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PlaceOrderResponse) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForOrders := "[]*Order{"
	for _, f := range this.Orders {
		repeatedStringForOrders += strings.Replace(f.String(), "Order", "Order", 1) + ","
	}
	repeatedStringForOrders += "}"
	s := strings.Join([]string{`&PlaceOrderResponse{`,
		`Orders:` + repeatedStringForOrders + `,`,
		`}`,
	}, "")
	return s
}
func (this *OrderParameters) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&OrderParameters{`,
		`Instrument:` + strings.Replace(this.Instrument.String(), "Instrument", "Instrument", 1) + `,`,
		`OrderType:` + fmt.Sprintf("%v", this.OrderType) + `,`,
		`LimitPrice:` + fmt.Sprintf("%v", this.LimitPrice) + `,`,
		`Side:` + fmt.Sprintf("%v", this.Side) + `,`,
		`IfDoneParentId:` + fmt.Sprintf("%v", this.IfDoneParentId) + `,`,
		`PlaceInterval:` + fmt.Sprintf("%v", this.PlaceInterval) + `,`,
		`Duration:` + fmt.Sprintf("%v", this.Duration) + `,`,
		`StopPrice:` + fmt.Sprintf("%v", this.StopPrice) + `,`,
		`Quantity:` + fmt.Sprintf("%v", this.Quantity) + `,`,
		`GttExpiration:` + fmt.Sprintf("%v", this.GttExpiration) + `,`,
		`OcoGroup:` + fmt.Sprintf("%v", this.OcoGroup) + `,`,
		`PriceDistance:` + fmt.Sprintf("%v", this.PriceDistance) + `,`,
		`PartQuantity:` + fmt.Sprintf("%v", this.PartQuantity) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Order) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Order{`,
		`CurrentModificationId:` + fmt.Sprintf("%v", this.CurrentModificationId) + `,`,
		`PlaceTime:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.PlaceTime), "Timestamp", "types.Timestamp", 1), `&`, ``, 1) + `,`,
		`Username:` + fmt.Sprintf("%v", this.Username) + `,`,
		`OrderId:` + fmt.Sprintf("%v", this.OrderId) + `,`,
		`OrderState:` + strings.Replace(this.OrderState.String(), "OrderState", "OrderState", 1) + `,`,
		`OrderParameters:` + strings.Replace(this.OrderParameters.String(), "OrderParameters", "OrderParameters", 1) + `,`,
		`ClientTag:` + fmt.Sprintf("%v", this.ClientTag) + `,`,
		`Account:` + fmt.Sprintf("%v", this.Account) + `,`,
		`}`,
	}, "")
	return s
}
func (this *OrderState) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForTrades := "[]Trade{"
	for _, f := range this.Trades {
		repeatedStringForTrades += strings.Replace(strings.Replace(f.String(), "Trade", "Trade", 1), `&`, ``, 1) + ","
	}
	repeatedStringForTrades += "}"
	s := strings.Join([]string{`&OrderState{`,
		`LastUpdateTime:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.LastUpdateTime), "Timestamp", "types.Timestamp", 1), `&`, ``, 1) + `,`,
		`Status:` + fmt.Sprintf("%v", this.Status) + `,`,
		`Reason:` + fmt.Sprintf("%v", this.Reason) + `,`,
		`Trades:` + repeatedStringForTrades + `,`,
		`}`,
	}, "")
	return s
}
func (this *Trade) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Trade{`,
		`Time:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.Time), "Timestamp", "types.Timestamp", 1), `&`, ``, 1) + `,`,
		`Quantity:` + fmt.Sprintf("%v", this.Quantity) + `,`,
		`Position:` + fmt.Sprintf("%v", this.Position) + `,`,
		`Price:` + fmt.Sprintf("%v", this.Price) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetAccountSummaryRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetAccountSummaryRequest{`,
		`Account:` + fmt.Sprintf("%v", this.Account) + `,`,
		`Currency:` + fmt.Sprintf("%v", this.Currency) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetAccountSummaryResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetAccountSummaryResponse{`,
		`AccountSummary:` + strings.Replace(this.AccountSummary.String(), "AccountSummary", "AccountSummary", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AccountSummary) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForPositions := "[]*Position{"
	for _, f := range this.Positions {
		repeatedStringForPositions += strings.Replace(f.String(), "Position", "Position", 1) + ","
	}
	repeatedStringForPositions += "}"
	repeatedStringForCurrencies := "[]*Currency{"
	for _, f := range this.Currencies {
		repeatedStringForCurrencies += strings.Replace(f.String(), "Currency", "Currency", 1) + ","
	}
	repeatedStringForCurrencies += "}"
	s := strings.Join([]string{`&AccountSummary{`,
		`NetAssetValue:` + fmt.Sprintf("%v", this.NetAssetValue) + `,`,
		`Positions:` + repeatedStringForPositions + `,`,
		`Currency:` + fmt.Sprintf("%v", this.Currency) + `,`,
		`MarginUtilization:` + fmt.Sprintf("%v", this.MarginUtilization) + `,`,
		`Timestamp:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.Timestamp), "Timestamp", "types.Timestamp", 1), `&`, ``, 1) + `,`,
		`MoneyUsedForMargin:` + fmt.Sprintf("%v", this.MoneyUsedForMargin) + `,`,
		`Currencies:` + repeatedStringForCurrencies + `,`,
		`Account:` + fmt.Sprintf("%v", this.Account) + `,`,
		`SessionDate:` + fmt.Sprintf("%v", this.SessionDate) + `,`,
		`FreeMoney:` + fmt.Sprintf("%v", this.FreeMoney) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Currency) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Currency{`,
		`Code:` + fmt.Sprintf("%v", this.Code) + `,`,
		`ConvertedValue:` + fmt.Sprintf("%v", this.ConvertedValue) + `,`,
		`Value:` + fmt.Sprintf("%v", this.Value) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Position) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Position{`,
		`ConvertedPnl:` + fmt.Sprintf("%v", this.ConvertedPnl) + `,`,
		`SymbolType:` + fmt.Sprintf("%v", this.SymbolType) + `,`,
		`Currency:` + fmt.Sprintf("%v", this.Currency) + `,`,
		`Id:` + fmt.Sprintf("%v", this.Id) + `,`,
		`Pnl:` + fmt.Sprintf("%v", this.Pnl) + `,`,
		`Price:` + fmt.Sprintf("%v", this.Price) + `,`,
		`Quantity:` + fmt.Sprintf("%v", this.Quantity) + `,`,
		`SymbolId:` + fmt.Sprintf("%v", this.SymbolId) + `,`,
		`ConvertedValue:` + fmt.Sprintf("%v", this.ConvertedValue) + `,`,
		`AveragePrice:` + fmt.Sprintf("%v", this.AveragePrice) + `,`,
		`Value:` + fmt.Sprintf("%v", this.Value) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TotalPosition) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TotalPosition{`,
		`Instrument:` + strings.Replace(this.Instrument.String(), "Instrument", "Instrument", 1) + `,`,
		`Quantity:` + fmt.Sprintf("%v", this.Quantity) + `,`,
		`LastUpdateTime:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.LastUpdateTime), "Timestamp", "types.Timestamp", 1), `&`, ``, 1) + `,`,
		`AveragePrice:` + fmt.Sprintf("%v", this.AveragePrice) + `,`,
		`Account:` + fmt.Sprintf("%v", this.Account) + `,`,
		`RealizedPnl:` + fmt.Sprintf("%v", this.RealizedPnl) + `,`,
		`DailyRealizedPnl:` + fmt.Sprintf("%v", this.DailyRealizedPnl) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CalculatedPosition) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CalculatedPosition{`,
		`Instrument:` + strings.Replace(this.Instrument.String(), "Instrument", "Instrument", 1) + `,`,
		`Quantity:` + fmt.Sprintf("%v", this.Quantity) + `,`,
		`LastUpdateTime:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.LastUpdateTime), "Timestamp", "types.Timestamp", 1), `&`, ``, 1) + `,`,
		`AveragePrice:` + fmt.Sprintf("%v", this.AveragePrice) + `,`,
		`Account:` + fmt.Sprintf("%v", this.Account) + `,`,
		`Strategy:` + fmt.Sprintf("%v", this.Strategy) + `,`,
		`RealizedPnl:` + fmt.Sprintf("%v", this.RealizedPnl) + `,`,
		`DailyRealizedPnl:` + fmt.Sprintf("%v", this.DailyRealizedPnl) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetPositionRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetPositionRequest{`,
		`Account:` + fmt.Sprintf("%v", this.Account) + `,`,
		`Strategy:` + fmt.Sprintf("%v", this.Strategy) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetPositionResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetPositionResponse{`,
		`CalculatedPosition:` + strings.Replace(this.CalculatedPosition.String(), "CalculatedPosition", "CalculatedPosition", 1) + `,`,
		`TotalPosition:` + strings.Replace(this.TotalPosition.String(), "TotalPosition", "TotalPosition", 1) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringOrder(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *GetOrderUpdateRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOrder
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetOrderUpdateRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetOrderUpdateRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipOrder(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOrder
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthOrder
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetOrderUpdateResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOrder
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetOrderUpdateResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetOrderUpdateResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Event", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrder
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrder
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Event = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Order", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOrder
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOrder
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Order == nil {
				m.Order = &Order{}
			}
			if err := m.Order.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOrder(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOrder
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthOrder
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PlaceOrderRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOrder
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PlaceOrderRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PlaceOrderRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Instrument", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOrder
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOrder
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Instrument == nil {
				m.Instrument = &Instrument{}
			}
			if err := m.Instrument.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrder
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrder
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OrderType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StopLoss", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrder
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrder
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StopLoss = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Quantity", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Quantity = float64(math.Float64frombits(v))
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Side", wireType)
			}
			m.Side = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Side |= Side(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdDoneParentId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrder
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrder
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IdDoneParentId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlaceInterval", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrder
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrder
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PlaceInterval = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Duration", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrder
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrder
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Duration = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OcoGroup", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrder
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrder
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OcoGroup = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TakeProfit", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrder
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrder
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TakeProfit = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StopPrice", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrder
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrder
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StopPrice = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientTag", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrder
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrder
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientTag = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LimitPrice", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrder
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrder
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LimitPrice = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GttExpiration", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrder
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrder
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GttExpiration = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Account", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrder
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrder
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Account = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PriceDistance", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrder
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrder
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PriceDistance = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartQuantity", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrder
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrder
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PartQuantity = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOrder(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOrder
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthOrder
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Instrument) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOrder
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Instrument: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Instrument: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrder
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrder
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Symbol", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrder
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrder
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Symbol = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrder
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrder
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOrder(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOrder
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthOrder
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PlaceOrderResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOrder
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PlaceOrderResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PlaceOrderResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Orders", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOrder
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOrder
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Orders = append(m.Orders, &Order{})
			if err := m.Orders[len(m.Orders)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOrder(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOrder
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthOrder
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OrderParameters) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOrder
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OrderParameters: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OrderParameters: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Instrument", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOrder
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOrder
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Instrument == nil {
				m.Instrument = &Instrument{}
			}
			if err := m.Instrument.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrder
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrder
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OrderType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LimitPrice", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrder
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrder
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LimitPrice = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Side", wireType)
			}
			m.Side = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Side |= Side(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IfDoneParentId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrder
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrder
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IfDoneParentId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlaceInterval", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrder
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrder
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PlaceInterval = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Duration", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrder
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrder
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Duration = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StopPrice", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrder
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrder
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StopPrice = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Quantity", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Quantity = float64(math.Float64frombits(v))
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GttExpiration", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrder
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrder
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GttExpiration = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OcoGroup", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrder
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrder
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OcoGroup = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PriceDistance", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrder
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrder
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PriceDistance = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartQuantity", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrder
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrder
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PartQuantity = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOrder(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOrder
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthOrder
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Order) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOrder
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Order: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Order: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrentModificationId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrder
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrder
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CurrentModificationId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlaceTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOrder
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOrder
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(&m.PlaceTime, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Username", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrder
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrder
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Username = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrder
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrder
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OrderId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderState", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOrder
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOrder
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OrderState == nil {
				m.OrderState = &OrderState{}
			}
			if err := m.OrderState.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderParameters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOrder
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOrder
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OrderParameters == nil {
				m.OrderParameters = &OrderParameters{}
			}
			if err := m.OrderParameters.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientTag", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrder
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrder
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientTag = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Account", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrder
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrder
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Account = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOrder(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOrder
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthOrder
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OrderState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOrder
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OrderState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OrderState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastUpdateTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOrder
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOrder
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(&m.LastUpdateTime, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= Status(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrder
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrder
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Trades", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOrder
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOrder
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Trades = append(m.Trades, Trade{})
			if err := m.Trades[len(m.Trades)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOrder(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOrder
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthOrder
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Trade) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOrder
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Trade: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Trade: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOrder
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOrder
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(&m.Time, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Quantity", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Quantity = float64(math.Float64frombits(v))
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Position", wireType)
			}
			m.Position = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Position |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Price", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Price = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipOrder(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOrder
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthOrder
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetAccountSummaryRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOrder
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetAccountSummaryRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetAccountSummaryRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Account", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrder
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrder
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Account = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Currency", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrder
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrder
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Currency = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOrder(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOrder
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthOrder
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetAccountSummaryResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOrder
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetAccountSummaryResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetAccountSummaryResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccountSummary", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOrder
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOrder
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AccountSummary == nil {
				m.AccountSummary = &AccountSummary{}
			}
			if err := m.AccountSummary.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOrder(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOrder
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthOrder
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AccountSummary) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOrder
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AccountSummary: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AccountSummary: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetAssetValue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrder
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrder
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NetAssetValue = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Positions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOrder
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOrder
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Positions = append(m.Positions, &Position{})
			if err := m.Positions[len(m.Positions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Currency", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrder
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrder
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Currency = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarginUtilization", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrder
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrder
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MarginUtilization = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOrder
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOrder
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(&m.Timestamp, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MoneyUsedForMargin", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrder
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrder
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MoneyUsedForMargin = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Currencies", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOrder
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOrder
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Currencies = append(m.Currencies, &Currency{})
			if err := m.Currencies[len(m.Currencies)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Account", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrder
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrder
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Account = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionDate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrder
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrder
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SessionDate = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FreeMoney", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrder
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrder
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FreeMoney = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOrder(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOrder
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthOrder
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Currency) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOrder
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Currency: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Currency: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrder
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrder
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Code = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConvertedValue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrder
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrder
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConvertedValue = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrder
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrder
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOrder(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOrder
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthOrder
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Position) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOrder
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Position: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Position: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConvertedPnl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrder
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrder
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConvertedPnl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SymbolType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrder
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrder
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SymbolType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Currency", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrder
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrder
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Currency = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrder
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrder
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pnl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrder
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrder
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Pnl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Price", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrder
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrder
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Price = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Quantity", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrder
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrder
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Quantity = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SymbolId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrder
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrder
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SymbolId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConvertedValue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrder
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrder
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConvertedValue = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AveragePrice", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrder
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrder
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AveragePrice = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrder
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrder
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOrder(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOrder
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthOrder
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TotalPosition) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOrder
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TotalPosition: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TotalPosition: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Instrument", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOrder
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOrder
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Instrument == nil {
				m.Instrument = &Instrument{}
			}
			if err := m.Instrument.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Quantity", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Quantity = float64(math.Float64frombits(v))
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastUpdateTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOrder
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOrder
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(&m.LastUpdateTime, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field AveragePrice", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.AveragePrice = float64(math.Float64frombits(v))
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Account", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrder
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrder
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Account = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field RealizedPnl", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.RealizedPnl = float64(math.Float64frombits(v))
		case 15:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field DailyRealizedPnl", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.DailyRealizedPnl = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipOrder(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOrder
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthOrder
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CalculatedPosition) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOrder
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CalculatedPosition: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CalculatedPosition: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Instrument", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOrder
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOrder
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Instrument == nil {
				m.Instrument = &Instrument{}
			}
			if err := m.Instrument.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Quantity", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Quantity = float64(math.Float64frombits(v))
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastUpdateTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOrder
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOrder
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(&m.LastUpdateTime, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field AveragePrice", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.AveragePrice = float64(math.Float64frombits(v))
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Account", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrder
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrder
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Account = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Strategy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrder
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrder
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Strategy = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field RealizedPnl", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.RealizedPnl = float64(math.Float64frombits(v))
		case 15:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field DailyRealizedPnl", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.DailyRealizedPnl = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipOrder(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOrder
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthOrder
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetPositionRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOrder
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetPositionRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetPositionRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Account", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrder
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrder
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Account = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Strategy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrder
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrder
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Strategy = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOrder(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOrder
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthOrder
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetPositionResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOrder
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetPositionResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetPositionResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CalculatedPosition", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOrder
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOrder
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CalculatedPosition == nil {
				m.CalculatedPosition = &CalculatedPosition{}
			}
			if err := m.CalculatedPosition.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalPosition", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOrder
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOrder
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TotalPosition == nil {
				m.TotalPosition = &TotalPosition{}
			}
			if err := m.TotalPosition.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOrder(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOrder
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthOrder
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipOrder(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowOrder
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthOrder
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupOrder
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthOrder
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthOrder        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowOrder          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupOrder = fmt.Errorf("proto: unexpected end of group")
)
