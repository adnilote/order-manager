package mock

// Code generated by http://github.com/gojuno/minimock (3.0.8). DO NOT EDIT.

import (
	"sync"
	mm_atomic "sync/atomic"
	"time"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	pb "github.com/adnilote/order-manager/app/business/entities/proto"
)

// StoreMock implements Store
type StoreMock struct {
	t minimock.Tester

	funcDeleteOrder          func(o1 pb.Order) (err error)
	inspectFuncDeleteOrder   func(o1 pb.Order)
	afterDeleteOrderCounter  uint64
	beforeDeleteOrderCounter uint64
	DeleteOrderMock          mStoreMockDeleteOrder

	funcGetOrder          func(s1 string) (o1 pb.Order, err error)
	inspectFuncGetOrder   func(s1 string)
	afterGetOrderCounter  uint64
	beforeGetOrderCounter uint64
	GetOrderMock          mStoreMockGetOrder

	funcGetPosition          func(account string, contractID string) (t1 pb.TotalPosition, err error)
	inspectFuncGetPosition   func(account string, contractID string)
	afterGetPositionCounter  uint64
	beforeGetPositionCounter uint64
	GetPositionMock          mStoreMockGetPosition

	funcSaveOrder          func(o1 pb.Order) (err error)
	inspectFuncSaveOrder   func(o1 pb.Order)
	afterSaveOrderCounter  uint64
	beforeSaveOrderCounter uint64
	SaveOrderMock          mStoreMockSaveOrder

	funcSaveOrderWithExpiration          func(order pb.Order, expiration time.Duration) (err error)
	inspectFuncSaveOrderWithExpiration   func(order pb.Order, expiration time.Duration)
	afterSaveOrderWithExpirationCounter  uint64
	beforeSaveOrderWithExpirationCounter uint64
	SaveOrderWithExpirationMock          mStoreMockSaveOrderWithExpiration

	funcSavePosition          func(t1 pb.TotalPosition) (err error)
	inspectFuncSavePosition   func(t1 pb.TotalPosition)
	afterSavePositionCounter  uint64
	beforeSavePositionCounter uint64
	SavePositionMock          mStoreMockSavePosition
}

// NewStoreMock returns a mock for Store
func NewStoreMock(t minimock.Tester) *StoreMock {
	m := &StoreMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.DeleteOrderMock = mStoreMockDeleteOrder{mock: m}
	m.DeleteOrderMock.callArgs = []*StoreMockDeleteOrderParams{}

	m.GetOrderMock = mStoreMockGetOrder{mock: m}
	m.GetOrderMock.callArgs = []*StoreMockGetOrderParams{}

	m.GetPositionMock = mStoreMockGetPosition{mock: m}
	m.GetPositionMock.callArgs = []*StoreMockGetPositionParams{}

	m.SaveOrderMock = mStoreMockSaveOrder{mock: m}
	m.SaveOrderMock.callArgs = []*StoreMockSaveOrderParams{}

	m.SaveOrderWithExpirationMock = mStoreMockSaveOrderWithExpiration{mock: m}
	m.SaveOrderWithExpirationMock.callArgs = []*StoreMockSaveOrderWithExpirationParams{}

	m.SavePositionMock = mStoreMockSavePosition{mock: m}
	m.SavePositionMock.callArgs = []*StoreMockSavePositionParams{}

	return m
}

type mStoreMockDeleteOrder struct {
	mock               *StoreMock
	defaultExpectation *StoreMockDeleteOrderExpectation
	expectations       []*StoreMockDeleteOrderExpectation

	callArgs []*StoreMockDeleteOrderParams
	mutex    sync.RWMutex
}

// StoreMockDeleteOrderExpectation specifies expectation struct of the Store.DeleteOrder
type StoreMockDeleteOrderExpectation struct {
	mock    *StoreMock
	params  *StoreMockDeleteOrderParams
	results *StoreMockDeleteOrderResults
	Counter uint64
}

// StoreMockDeleteOrderParams contains parameters of the Store.DeleteOrder
type StoreMockDeleteOrderParams struct {
	o1 pb.Order
}

// StoreMockDeleteOrderResults contains results of the Store.DeleteOrder
type StoreMockDeleteOrderResults struct {
	err error
}

// Expect sets up expected params for Store.DeleteOrder
func (mmDeleteOrder *mStoreMockDeleteOrder) Expect(o1 pb.Order) *mStoreMockDeleteOrder {
	if mmDeleteOrder.mock.funcDeleteOrder != nil {
		mmDeleteOrder.mock.t.Fatalf("StoreMock.DeleteOrder mock is already set by Set")
	}

	if mmDeleteOrder.defaultExpectation == nil {
		mmDeleteOrder.defaultExpectation = &StoreMockDeleteOrderExpectation{}
	}

	mmDeleteOrder.defaultExpectation.params = &StoreMockDeleteOrderParams{o1}
	for _, e := range mmDeleteOrder.expectations {
		if minimock.Equal(e.params, mmDeleteOrder.defaultExpectation.params) {
			mmDeleteOrder.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteOrder.defaultExpectation.params)
		}
	}

	return mmDeleteOrder
}

// Inspect accepts an inspector function that has same arguments as the Store.DeleteOrder
func (mmDeleteOrder *mStoreMockDeleteOrder) Inspect(f func(o1 pb.Order)) *mStoreMockDeleteOrder {
	if mmDeleteOrder.mock.inspectFuncDeleteOrder != nil {
		mmDeleteOrder.mock.t.Fatalf("Inspect function is already set for StoreMock.DeleteOrder")
	}

	mmDeleteOrder.mock.inspectFuncDeleteOrder = f

	return mmDeleteOrder
}

// Return sets up results that will be returned by Store.DeleteOrder
func (mmDeleteOrder *mStoreMockDeleteOrder) Return(err error) *StoreMock {
	if mmDeleteOrder.mock.funcDeleteOrder != nil {
		mmDeleteOrder.mock.t.Fatalf("StoreMock.DeleteOrder mock is already set by Set")
	}

	if mmDeleteOrder.defaultExpectation == nil {
		mmDeleteOrder.defaultExpectation = &StoreMockDeleteOrderExpectation{mock: mmDeleteOrder.mock}
	}
	mmDeleteOrder.defaultExpectation.results = &StoreMockDeleteOrderResults{err}
	return mmDeleteOrder.mock
}

//Set uses given function f to mock the Store.DeleteOrder method
func (mmDeleteOrder *mStoreMockDeleteOrder) Set(f func(o1 pb.Order) (err error)) *StoreMock {
	if mmDeleteOrder.defaultExpectation != nil {
		mmDeleteOrder.mock.t.Fatalf("Default expectation is already set for the Store.DeleteOrder method")
	}

	if len(mmDeleteOrder.expectations) > 0 {
		mmDeleteOrder.mock.t.Fatalf("Some expectations are already set for the Store.DeleteOrder method")
	}

	mmDeleteOrder.mock.funcDeleteOrder = f
	return mmDeleteOrder.mock
}

// When sets expectation for the Store.DeleteOrder which will trigger the result defined by the following
// Then helper
func (mmDeleteOrder *mStoreMockDeleteOrder) When(o1 pb.Order) *StoreMockDeleteOrderExpectation {
	if mmDeleteOrder.mock.funcDeleteOrder != nil {
		mmDeleteOrder.mock.t.Fatalf("StoreMock.DeleteOrder mock is already set by Set")
	}

	expectation := &StoreMockDeleteOrderExpectation{
		mock:   mmDeleteOrder.mock,
		params: &StoreMockDeleteOrderParams{o1},
	}
	mmDeleteOrder.expectations = append(mmDeleteOrder.expectations, expectation)
	return expectation
}

// Then sets up Store.DeleteOrder return parameters for the expectation previously defined by the When method
func (e *StoreMockDeleteOrderExpectation) Then(err error) *StoreMock {
	e.results = &StoreMockDeleteOrderResults{err}
	return e.mock
}

// DeleteOrder implements Store
func (mmDeleteOrder *StoreMock) DeleteOrder(o1 pb.Order) (err error) {
	mm_atomic.AddUint64(&mmDeleteOrder.beforeDeleteOrderCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteOrder.afterDeleteOrderCounter, 1)

	if mmDeleteOrder.inspectFuncDeleteOrder != nil {
		mmDeleteOrder.inspectFuncDeleteOrder(o1)
	}

	mm_params := &StoreMockDeleteOrderParams{o1}

	// Record call args
	mmDeleteOrder.DeleteOrderMock.mutex.Lock()
	mmDeleteOrder.DeleteOrderMock.callArgs = append(mmDeleteOrder.DeleteOrderMock.callArgs, mm_params)
	mmDeleteOrder.DeleteOrderMock.mutex.Unlock()

	for _, e := range mmDeleteOrder.DeleteOrderMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteOrder.DeleteOrderMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteOrder.DeleteOrderMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteOrder.DeleteOrderMock.defaultExpectation.params
		mm_got := StoreMockDeleteOrderParams{o1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteOrder.t.Errorf("StoreMock.DeleteOrder got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteOrder.DeleteOrderMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteOrder.t.Fatal("No results are set for the StoreMock.DeleteOrder")
		}
		return (*mm_results).err
	}
	if mmDeleteOrder.funcDeleteOrder != nil {
		return mmDeleteOrder.funcDeleteOrder(o1)
	}
	mmDeleteOrder.t.Fatalf("Unexpected call to StoreMock.DeleteOrder. %v", o1)
	return
}

// DeleteOrderAfterCounter returns a count of finished StoreMock.DeleteOrder invocations
func (mmDeleteOrder *StoreMock) DeleteOrderAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteOrder.afterDeleteOrderCounter)
}

// DeleteOrderBeforeCounter returns a count of StoreMock.DeleteOrder invocations
func (mmDeleteOrder *StoreMock) DeleteOrderBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteOrder.beforeDeleteOrderCounter)
}

// Calls returns a list of arguments used in each call to StoreMock.DeleteOrder.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteOrder *mStoreMockDeleteOrder) Calls() []*StoreMockDeleteOrderParams {
	mmDeleteOrder.mutex.RLock()

	argCopy := make([]*StoreMockDeleteOrderParams, len(mmDeleteOrder.callArgs))
	copy(argCopy, mmDeleteOrder.callArgs)

	mmDeleteOrder.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteOrderDone returns true if the count of the DeleteOrder invocations corresponds
// the number of defined expectations
func (m *StoreMock) MinimockDeleteOrderDone() bool {
	for _, e := range m.DeleteOrderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteOrderMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteOrderCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteOrder != nil && mm_atomic.LoadUint64(&m.afterDeleteOrderCounter) < 1 {
		return false
	}
	return true
}

// MinimockDeleteOrderInspect logs each unmet expectation
func (m *StoreMock) MinimockDeleteOrderInspect() {
	for _, e := range m.DeleteOrderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StoreMock.DeleteOrder with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteOrderMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteOrderCounter) < 1 {
		if m.DeleteOrderMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to StoreMock.DeleteOrder")
		} else {
			m.t.Errorf("Expected call to StoreMock.DeleteOrder with params: %#v", *m.DeleteOrderMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteOrder != nil && mm_atomic.LoadUint64(&m.afterDeleteOrderCounter) < 1 {
		m.t.Error("Expected call to StoreMock.DeleteOrder")
	}
}

type mStoreMockGetOrder struct {
	mock               *StoreMock
	defaultExpectation *StoreMockGetOrderExpectation
	expectations       []*StoreMockGetOrderExpectation

	callArgs []*StoreMockGetOrderParams
	mutex    sync.RWMutex
}

// StoreMockGetOrderExpectation specifies expectation struct of the Store.GetOrder
type StoreMockGetOrderExpectation struct {
	mock    *StoreMock
	params  *StoreMockGetOrderParams
	results *StoreMockGetOrderResults
	Counter uint64
}

// StoreMockGetOrderParams contains parameters of the Store.GetOrder
type StoreMockGetOrderParams struct {
	s1 string
}

// StoreMockGetOrderResults contains results of the Store.GetOrder
type StoreMockGetOrderResults struct {
	o1  pb.Order
	err error
}

// Expect sets up expected params for Store.GetOrder
func (mmGetOrder *mStoreMockGetOrder) Expect(s1 string) *mStoreMockGetOrder {
	if mmGetOrder.mock.funcGetOrder != nil {
		mmGetOrder.mock.t.Fatalf("StoreMock.GetOrder mock is already set by Set")
	}

	if mmGetOrder.defaultExpectation == nil {
		mmGetOrder.defaultExpectation = &StoreMockGetOrderExpectation{}
	}

	mmGetOrder.defaultExpectation.params = &StoreMockGetOrderParams{s1}
	for _, e := range mmGetOrder.expectations {
		if minimock.Equal(e.params, mmGetOrder.defaultExpectation.params) {
			mmGetOrder.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetOrder.defaultExpectation.params)
		}
	}

	return mmGetOrder
}

// Inspect accepts an inspector function that has same arguments as the Store.GetOrder
func (mmGetOrder *mStoreMockGetOrder) Inspect(f func(s1 string)) *mStoreMockGetOrder {
	if mmGetOrder.mock.inspectFuncGetOrder != nil {
		mmGetOrder.mock.t.Fatalf("Inspect function is already set for StoreMock.GetOrder")
	}

	mmGetOrder.mock.inspectFuncGetOrder = f

	return mmGetOrder
}

// Return sets up results that will be returned by Store.GetOrder
func (mmGetOrder *mStoreMockGetOrder) Return(o1 pb.Order, err error) *StoreMock {
	if mmGetOrder.mock.funcGetOrder != nil {
		mmGetOrder.mock.t.Fatalf("StoreMock.GetOrder mock is already set by Set")
	}

	if mmGetOrder.defaultExpectation == nil {
		mmGetOrder.defaultExpectation = &StoreMockGetOrderExpectation{mock: mmGetOrder.mock}
	}
	mmGetOrder.defaultExpectation.results = &StoreMockGetOrderResults{o1, err}
	return mmGetOrder.mock
}

//Set uses given function f to mock the Store.GetOrder method
func (mmGetOrder *mStoreMockGetOrder) Set(f func(s1 string) (o1 pb.Order, err error)) *StoreMock {
	if mmGetOrder.defaultExpectation != nil {
		mmGetOrder.mock.t.Fatalf("Default expectation is already set for the Store.GetOrder method")
	}

	if len(mmGetOrder.expectations) > 0 {
		mmGetOrder.mock.t.Fatalf("Some expectations are already set for the Store.GetOrder method")
	}

	mmGetOrder.mock.funcGetOrder = f
	return mmGetOrder.mock
}

// When sets expectation for the Store.GetOrder which will trigger the result defined by the following
// Then helper
func (mmGetOrder *mStoreMockGetOrder) When(s1 string) *StoreMockGetOrderExpectation {
	if mmGetOrder.mock.funcGetOrder != nil {
		mmGetOrder.mock.t.Fatalf("StoreMock.GetOrder mock is already set by Set")
	}

	expectation := &StoreMockGetOrderExpectation{
		mock:   mmGetOrder.mock,
		params: &StoreMockGetOrderParams{s1},
	}
	mmGetOrder.expectations = append(mmGetOrder.expectations, expectation)
	return expectation
}

// Then sets up Store.GetOrder return parameters for the expectation previously defined by the When method
func (e *StoreMockGetOrderExpectation) Then(o1 pb.Order, err error) *StoreMock {
	e.results = &StoreMockGetOrderResults{o1, err}
	return e.mock
}

// GetOrder implements Store
func (mmGetOrder *StoreMock) GetOrder(s1 string) (o1 pb.Order, err error) {
	mm_atomic.AddUint64(&mmGetOrder.beforeGetOrderCounter, 1)
	defer mm_atomic.AddUint64(&mmGetOrder.afterGetOrderCounter, 1)

	if mmGetOrder.inspectFuncGetOrder != nil {
		mmGetOrder.inspectFuncGetOrder(s1)
	}

	mm_params := &StoreMockGetOrderParams{s1}

	// Record call args
	mmGetOrder.GetOrderMock.mutex.Lock()
	mmGetOrder.GetOrderMock.callArgs = append(mmGetOrder.GetOrderMock.callArgs, mm_params)
	mmGetOrder.GetOrderMock.mutex.Unlock()

	for _, e := range mmGetOrder.GetOrderMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.o1, e.results.err
		}
	}

	if mmGetOrder.GetOrderMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetOrder.GetOrderMock.defaultExpectation.Counter, 1)
		mm_want := mmGetOrder.GetOrderMock.defaultExpectation.params
		mm_got := StoreMockGetOrderParams{s1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetOrder.t.Errorf("StoreMock.GetOrder got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetOrder.GetOrderMock.defaultExpectation.results
		if mm_results == nil {
			mmGetOrder.t.Fatal("No results are set for the StoreMock.GetOrder")
		}
		return (*mm_results).o1, (*mm_results).err
	}
	if mmGetOrder.funcGetOrder != nil {
		return mmGetOrder.funcGetOrder(s1)
	}
	mmGetOrder.t.Fatalf("Unexpected call to StoreMock.GetOrder. %v", s1)
	return
}

// GetOrderAfterCounter returns a count of finished StoreMock.GetOrder invocations
func (mmGetOrder *StoreMock) GetOrderAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetOrder.afterGetOrderCounter)
}

// GetOrderBeforeCounter returns a count of StoreMock.GetOrder invocations
func (mmGetOrder *StoreMock) GetOrderBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetOrder.beforeGetOrderCounter)
}

// Calls returns a list of arguments used in each call to StoreMock.GetOrder.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetOrder *mStoreMockGetOrder) Calls() []*StoreMockGetOrderParams {
	mmGetOrder.mutex.RLock()

	argCopy := make([]*StoreMockGetOrderParams, len(mmGetOrder.callArgs))
	copy(argCopy, mmGetOrder.callArgs)

	mmGetOrder.mutex.RUnlock()

	return argCopy
}

// MinimockGetOrderDone returns true if the count of the GetOrder invocations corresponds
// the number of defined expectations
func (m *StoreMock) MinimockGetOrderDone() bool {
	for _, e := range m.GetOrderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetOrderMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetOrderCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetOrder != nil && mm_atomic.LoadUint64(&m.afterGetOrderCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetOrderInspect logs each unmet expectation
func (m *StoreMock) MinimockGetOrderInspect() {
	for _, e := range m.GetOrderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StoreMock.GetOrder with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetOrderMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetOrderCounter) < 1 {
		if m.GetOrderMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to StoreMock.GetOrder")
		} else {
			m.t.Errorf("Expected call to StoreMock.GetOrder with params: %#v", *m.GetOrderMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetOrder != nil && mm_atomic.LoadUint64(&m.afterGetOrderCounter) < 1 {
		m.t.Error("Expected call to StoreMock.GetOrder")
	}
}

type mStoreMockGetPosition struct {
	mock               *StoreMock
	defaultExpectation *StoreMockGetPositionExpectation
	expectations       []*StoreMockGetPositionExpectation

	callArgs []*StoreMockGetPositionParams
	mutex    sync.RWMutex
}

// StoreMockGetPositionExpectation specifies expectation struct of the Store.GetPosition
type StoreMockGetPositionExpectation struct {
	mock    *StoreMock
	params  *StoreMockGetPositionParams
	results *StoreMockGetPositionResults
	Counter uint64
}

// StoreMockGetPositionParams contains parameters of the Store.GetPosition
type StoreMockGetPositionParams struct {
	account    string
	contractID string
}

// StoreMockGetPositionResults contains results of the Store.GetPosition
type StoreMockGetPositionResults struct {
	t1  pb.TotalPosition
	err error
}

// Expect sets up expected params for Store.GetPosition
func (mmGetPosition *mStoreMockGetPosition) Expect(account string, contractID string) *mStoreMockGetPosition {
	if mmGetPosition.mock.funcGetPosition != nil {
		mmGetPosition.mock.t.Fatalf("StoreMock.GetPosition mock is already set by Set")
	}

	if mmGetPosition.defaultExpectation == nil {
		mmGetPosition.defaultExpectation = &StoreMockGetPositionExpectation{}
	}

	mmGetPosition.defaultExpectation.params = &StoreMockGetPositionParams{account, contractID}
	for _, e := range mmGetPosition.expectations {
		if minimock.Equal(e.params, mmGetPosition.defaultExpectation.params) {
			mmGetPosition.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetPosition.defaultExpectation.params)
		}
	}

	return mmGetPosition
}

// Inspect accepts an inspector function that has same arguments as the Store.GetPosition
func (mmGetPosition *mStoreMockGetPosition) Inspect(f func(account string, contractID string)) *mStoreMockGetPosition {
	if mmGetPosition.mock.inspectFuncGetPosition != nil {
		mmGetPosition.mock.t.Fatalf("Inspect function is already set for StoreMock.GetPosition")
	}

	mmGetPosition.mock.inspectFuncGetPosition = f

	return mmGetPosition
}

// Return sets up results that will be returned by Store.GetPosition
func (mmGetPosition *mStoreMockGetPosition) Return(t1 pb.TotalPosition, err error) *StoreMock {
	if mmGetPosition.mock.funcGetPosition != nil {
		mmGetPosition.mock.t.Fatalf("StoreMock.GetPosition mock is already set by Set")
	}

	if mmGetPosition.defaultExpectation == nil {
		mmGetPosition.defaultExpectation = &StoreMockGetPositionExpectation{mock: mmGetPosition.mock}
	}
	mmGetPosition.defaultExpectation.results = &StoreMockGetPositionResults{t1, err}
	return mmGetPosition.mock
}

//Set uses given function f to mock the Store.GetPosition method
func (mmGetPosition *mStoreMockGetPosition) Set(f func(account string, contractID string) (t1 pb.TotalPosition, err error)) *StoreMock {
	if mmGetPosition.defaultExpectation != nil {
		mmGetPosition.mock.t.Fatalf("Default expectation is already set for the Store.GetPosition method")
	}

	if len(mmGetPosition.expectations) > 0 {
		mmGetPosition.mock.t.Fatalf("Some expectations are already set for the Store.GetPosition method")
	}

	mmGetPosition.mock.funcGetPosition = f
	return mmGetPosition.mock
}

// When sets expectation for the Store.GetPosition which will trigger the result defined by the following
// Then helper
func (mmGetPosition *mStoreMockGetPosition) When(account string, contractID string) *StoreMockGetPositionExpectation {
	if mmGetPosition.mock.funcGetPosition != nil {
		mmGetPosition.mock.t.Fatalf("StoreMock.GetPosition mock is already set by Set")
	}

	expectation := &StoreMockGetPositionExpectation{
		mock:   mmGetPosition.mock,
		params: &StoreMockGetPositionParams{account, contractID},
	}
	mmGetPosition.expectations = append(mmGetPosition.expectations, expectation)
	return expectation
}

// Then sets up Store.GetPosition return parameters for the expectation previously defined by the When method
func (e *StoreMockGetPositionExpectation) Then(t1 pb.TotalPosition, err error) *StoreMock {
	e.results = &StoreMockGetPositionResults{t1, err}
	return e.mock
}

// GetPosition implements Store
func (mmGetPosition *StoreMock) GetPosition(account string, contractID string) (t1 pb.TotalPosition, err error) {
	mm_atomic.AddUint64(&mmGetPosition.beforeGetPositionCounter, 1)
	defer mm_atomic.AddUint64(&mmGetPosition.afterGetPositionCounter, 1)

	if mmGetPosition.inspectFuncGetPosition != nil {
		mmGetPosition.inspectFuncGetPosition(account, contractID)
	}

	mm_params := &StoreMockGetPositionParams{account, contractID}

	// Record call args
	mmGetPosition.GetPositionMock.mutex.Lock()
	mmGetPosition.GetPositionMock.callArgs = append(mmGetPosition.GetPositionMock.callArgs, mm_params)
	mmGetPosition.GetPositionMock.mutex.Unlock()

	for _, e := range mmGetPosition.GetPositionMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.t1, e.results.err
		}
	}

	if mmGetPosition.GetPositionMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetPosition.GetPositionMock.defaultExpectation.Counter, 1)
		mm_want := mmGetPosition.GetPositionMock.defaultExpectation.params
		mm_got := StoreMockGetPositionParams{account, contractID}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetPosition.t.Errorf("StoreMock.GetPosition got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetPosition.GetPositionMock.defaultExpectation.results
		if mm_results == nil {
			mmGetPosition.t.Fatal("No results are set for the StoreMock.GetPosition")
		}
		return (*mm_results).t1, (*mm_results).err
	}
	if mmGetPosition.funcGetPosition != nil {
		return mmGetPosition.funcGetPosition(account, contractID)
	}
	mmGetPosition.t.Fatalf("Unexpected call to StoreMock.GetPosition. %v %v", account, contractID)
	return
}

// GetPositionAfterCounter returns a count of finished StoreMock.GetPosition invocations
func (mmGetPosition *StoreMock) GetPositionAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetPosition.afterGetPositionCounter)
}

// GetPositionBeforeCounter returns a count of StoreMock.GetPosition invocations
func (mmGetPosition *StoreMock) GetPositionBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetPosition.beforeGetPositionCounter)
}

// Calls returns a list of arguments used in each call to StoreMock.GetPosition.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetPosition *mStoreMockGetPosition) Calls() []*StoreMockGetPositionParams {
	mmGetPosition.mutex.RLock()

	argCopy := make([]*StoreMockGetPositionParams, len(mmGetPosition.callArgs))
	copy(argCopy, mmGetPosition.callArgs)

	mmGetPosition.mutex.RUnlock()

	return argCopy
}

// MinimockGetPositionDone returns true if the count of the GetPosition invocations corresponds
// the number of defined expectations
func (m *StoreMock) MinimockGetPositionDone() bool {
	for _, e := range m.GetPositionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetPositionMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetPositionCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetPosition != nil && mm_atomic.LoadUint64(&m.afterGetPositionCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetPositionInspect logs each unmet expectation
func (m *StoreMock) MinimockGetPositionInspect() {
	for _, e := range m.GetPositionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StoreMock.GetPosition with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetPositionMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetPositionCounter) < 1 {
		if m.GetPositionMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to StoreMock.GetPosition")
		} else {
			m.t.Errorf("Expected call to StoreMock.GetPosition with params: %#v", *m.GetPositionMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetPosition != nil && mm_atomic.LoadUint64(&m.afterGetPositionCounter) < 1 {
		m.t.Error("Expected call to StoreMock.GetPosition")
	}
}

type mStoreMockSaveOrder struct {
	mock               *StoreMock
	defaultExpectation *StoreMockSaveOrderExpectation
	expectations       []*StoreMockSaveOrderExpectation

	callArgs []*StoreMockSaveOrderParams
	mutex    sync.RWMutex
}

// StoreMockSaveOrderExpectation specifies expectation struct of the Store.SaveOrder
type StoreMockSaveOrderExpectation struct {
	mock    *StoreMock
	params  *StoreMockSaveOrderParams
	results *StoreMockSaveOrderResults
	Counter uint64
}

// StoreMockSaveOrderParams contains parameters of the Store.SaveOrder
type StoreMockSaveOrderParams struct {
	o1 pb.Order
}

// StoreMockSaveOrderResults contains results of the Store.SaveOrder
type StoreMockSaveOrderResults struct {
	err error
}

// Expect sets up expected params for Store.SaveOrder
func (mmSaveOrder *mStoreMockSaveOrder) Expect(o1 pb.Order) *mStoreMockSaveOrder {
	if mmSaveOrder.mock.funcSaveOrder != nil {
		mmSaveOrder.mock.t.Fatalf("StoreMock.SaveOrder mock is already set by Set")
	}

	if mmSaveOrder.defaultExpectation == nil {
		mmSaveOrder.defaultExpectation = &StoreMockSaveOrderExpectation{}
	}

	mmSaveOrder.defaultExpectation.params = &StoreMockSaveOrderParams{o1}
	for _, e := range mmSaveOrder.expectations {
		if minimock.Equal(e.params, mmSaveOrder.defaultExpectation.params) {
			mmSaveOrder.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSaveOrder.defaultExpectation.params)
		}
	}

	return mmSaveOrder
}

// Inspect accepts an inspector function that has same arguments as the Store.SaveOrder
func (mmSaveOrder *mStoreMockSaveOrder) Inspect(f func(o1 pb.Order)) *mStoreMockSaveOrder {
	if mmSaveOrder.mock.inspectFuncSaveOrder != nil {
		mmSaveOrder.mock.t.Fatalf("Inspect function is already set for StoreMock.SaveOrder")
	}

	mmSaveOrder.mock.inspectFuncSaveOrder = f

	return mmSaveOrder
}

// Return sets up results that will be returned by Store.SaveOrder
func (mmSaveOrder *mStoreMockSaveOrder) Return(err error) *StoreMock {
	if mmSaveOrder.mock.funcSaveOrder != nil {
		mmSaveOrder.mock.t.Fatalf("StoreMock.SaveOrder mock is already set by Set")
	}

	if mmSaveOrder.defaultExpectation == nil {
		mmSaveOrder.defaultExpectation = &StoreMockSaveOrderExpectation{mock: mmSaveOrder.mock}
	}
	mmSaveOrder.defaultExpectation.results = &StoreMockSaveOrderResults{err}
	return mmSaveOrder.mock
}

//Set uses given function f to mock the Store.SaveOrder method
func (mmSaveOrder *mStoreMockSaveOrder) Set(f func(o1 pb.Order) (err error)) *StoreMock {
	if mmSaveOrder.defaultExpectation != nil {
		mmSaveOrder.mock.t.Fatalf("Default expectation is already set for the Store.SaveOrder method")
	}

	if len(mmSaveOrder.expectations) > 0 {
		mmSaveOrder.mock.t.Fatalf("Some expectations are already set for the Store.SaveOrder method")
	}

	mmSaveOrder.mock.funcSaveOrder = f
	return mmSaveOrder.mock
}

// When sets expectation for the Store.SaveOrder which will trigger the result defined by the following
// Then helper
func (mmSaveOrder *mStoreMockSaveOrder) When(o1 pb.Order) *StoreMockSaveOrderExpectation {
	if mmSaveOrder.mock.funcSaveOrder != nil {
		mmSaveOrder.mock.t.Fatalf("StoreMock.SaveOrder mock is already set by Set")
	}

	expectation := &StoreMockSaveOrderExpectation{
		mock:   mmSaveOrder.mock,
		params: &StoreMockSaveOrderParams{o1},
	}
	mmSaveOrder.expectations = append(mmSaveOrder.expectations, expectation)
	return expectation
}

// Then sets up Store.SaveOrder return parameters for the expectation previously defined by the When method
func (e *StoreMockSaveOrderExpectation) Then(err error) *StoreMock {
	e.results = &StoreMockSaveOrderResults{err}
	return e.mock
}

// SaveOrder implements Store
func (mmSaveOrder *StoreMock) SaveOrder(o1 pb.Order) (err error) {
	mm_atomic.AddUint64(&mmSaveOrder.beforeSaveOrderCounter, 1)
	defer mm_atomic.AddUint64(&mmSaveOrder.afterSaveOrderCounter, 1)

	if mmSaveOrder.inspectFuncSaveOrder != nil {
		mmSaveOrder.inspectFuncSaveOrder(o1)
	}

	mm_params := &StoreMockSaveOrderParams{o1}

	// Record call args
	mmSaveOrder.SaveOrderMock.mutex.Lock()
	mmSaveOrder.SaveOrderMock.callArgs = append(mmSaveOrder.SaveOrderMock.callArgs, mm_params)
	mmSaveOrder.SaveOrderMock.mutex.Unlock()

	for _, e := range mmSaveOrder.SaveOrderMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSaveOrder.SaveOrderMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSaveOrder.SaveOrderMock.defaultExpectation.Counter, 1)
		mm_want := mmSaveOrder.SaveOrderMock.defaultExpectation.params
		mm_got := StoreMockSaveOrderParams{o1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSaveOrder.t.Errorf("StoreMock.SaveOrder got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSaveOrder.SaveOrderMock.defaultExpectation.results
		if mm_results == nil {
			mmSaveOrder.t.Fatal("No results are set for the StoreMock.SaveOrder")
		}
		return (*mm_results).err
	}
	if mmSaveOrder.funcSaveOrder != nil {
		return mmSaveOrder.funcSaveOrder(o1)
	}
	mmSaveOrder.t.Fatalf("Unexpected call to StoreMock.SaveOrder. %v", o1)
	return
}

// SaveOrderAfterCounter returns a count of finished StoreMock.SaveOrder invocations
func (mmSaveOrder *StoreMock) SaveOrderAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSaveOrder.afterSaveOrderCounter)
}

// SaveOrderBeforeCounter returns a count of StoreMock.SaveOrder invocations
func (mmSaveOrder *StoreMock) SaveOrderBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSaveOrder.beforeSaveOrderCounter)
}

// Calls returns a list of arguments used in each call to StoreMock.SaveOrder.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSaveOrder *mStoreMockSaveOrder) Calls() []*StoreMockSaveOrderParams {
	mmSaveOrder.mutex.RLock()

	argCopy := make([]*StoreMockSaveOrderParams, len(mmSaveOrder.callArgs))
	copy(argCopy, mmSaveOrder.callArgs)

	mmSaveOrder.mutex.RUnlock()

	return argCopy
}

// MinimockSaveOrderDone returns true if the count of the SaveOrder invocations corresponds
// the number of defined expectations
func (m *StoreMock) MinimockSaveOrderDone() bool {
	for _, e := range m.SaveOrderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SaveOrderMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSaveOrderCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSaveOrder != nil && mm_atomic.LoadUint64(&m.afterSaveOrderCounter) < 1 {
		return false
	}
	return true
}

// MinimockSaveOrderInspect logs each unmet expectation
func (m *StoreMock) MinimockSaveOrderInspect() {
	for _, e := range m.SaveOrderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StoreMock.SaveOrder with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SaveOrderMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSaveOrderCounter) < 1 {
		if m.SaveOrderMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to StoreMock.SaveOrder")
		} else {
			m.t.Errorf("Expected call to StoreMock.SaveOrder with params: %#v", *m.SaveOrderMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSaveOrder != nil && mm_atomic.LoadUint64(&m.afterSaveOrderCounter) < 1 {
		m.t.Error("Expected call to StoreMock.SaveOrder")
	}
}

type mStoreMockSaveOrderWithExpiration struct {
	mock               *StoreMock
	defaultExpectation *StoreMockSaveOrderWithExpirationExpectation
	expectations       []*StoreMockSaveOrderWithExpirationExpectation

	callArgs []*StoreMockSaveOrderWithExpirationParams
	mutex    sync.RWMutex
}

// StoreMockSaveOrderWithExpirationExpectation specifies expectation struct of the Store.SaveOrderWithExpiration
type StoreMockSaveOrderWithExpirationExpectation struct {
	mock    *StoreMock
	params  *StoreMockSaveOrderWithExpirationParams
	results *StoreMockSaveOrderWithExpirationResults
	Counter uint64
}

// StoreMockSaveOrderWithExpirationParams contains parameters of the Store.SaveOrderWithExpiration
type StoreMockSaveOrderWithExpirationParams struct {
	order      pb.Order
	expiration time.Duration
}

// StoreMockSaveOrderWithExpirationResults contains results of the Store.SaveOrderWithExpiration
type StoreMockSaveOrderWithExpirationResults struct {
	err error
}

// Expect sets up expected params for Store.SaveOrderWithExpiration
func (mmSaveOrderWithExpiration *mStoreMockSaveOrderWithExpiration) Expect(order pb.Order, expiration time.Duration) *mStoreMockSaveOrderWithExpiration {
	if mmSaveOrderWithExpiration.mock.funcSaveOrderWithExpiration != nil {
		mmSaveOrderWithExpiration.mock.t.Fatalf("StoreMock.SaveOrderWithExpiration mock is already set by Set")
	}

	if mmSaveOrderWithExpiration.defaultExpectation == nil {
		mmSaveOrderWithExpiration.defaultExpectation = &StoreMockSaveOrderWithExpirationExpectation{}
	}

	mmSaveOrderWithExpiration.defaultExpectation.params = &StoreMockSaveOrderWithExpirationParams{order, expiration}
	for _, e := range mmSaveOrderWithExpiration.expectations {
		if minimock.Equal(e.params, mmSaveOrderWithExpiration.defaultExpectation.params) {
			mmSaveOrderWithExpiration.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSaveOrderWithExpiration.defaultExpectation.params)
		}
	}

	return mmSaveOrderWithExpiration
}

// Inspect accepts an inspector function that has same arguments as the Store.SaveOrderWithExpiration
func (mmSaveOrderWithExpiration *mStoreMockSaveOrderWithExpiration) Inspect(f func(order pb.Order, expiration time.Duration)) *mStoreMockSaveOrderWithExpiration {
	if mmSaveOrderWithExpiration.mock.inspectFuncSaveOrderWithExpiration != nil {
		mmSaveOrderWithExpiration.mock.t.Fatalf("Inspect function is already set for StoreMock.SaveOrderWithExpiration")
	}

	mmSaveOrderWithExpiration.mock.inspectFuncSaveOrderWithExpiration = f

	return mmSaveOrderWithExpiration
}

// Return sets up results that will be returned by Store.SaveOrderWithExpiration
func (mmSaveOrderWithExpiration *mStoreMockSaveOrderWithExpiration) Return(err error) *StoreMock {
	if mmSaveOrderWithExpiration.mock.funcSaveOrderWithExpiration != nil {
		mmSaveOrderWithExpiration.mock.t.Fatalf("StoreMock.SaveOrderWithExpiration mock is already set by Set")
	}

	if mmSaveOrderWithExpiration.defaultExpectation == nil {
		mmSaveOrderWithExpiration.defaultExpectation = &StoreMockSaveOrderWithExpirationExpectation{mock: mmSaveOrderWithExpiration.mock}
	}
	mmSaveOrderWithExpiration.defaultExpectation.results = &StoreMockSaveOrderWithExpirationResults{err}
	return mmSaveOrderWithExpiration.mock
}

//Set uses given function f to mock the Store.SaveOrderWithExpiration method
func (mmSaveOrderWithExpiration *mStoreMockSaveOrderWithExpiration) Set(f func(order pb.Order, expiration time.Duration) (err error)) *StoreMock {
	if mmSaveOrderWithExpiration.defaultExpectation != nil {
		mmSaveOrderWithExpiration.mock.t.Fatalf("Default expectation is already set for the Store.SaveOrderWithExpiration method")
	}

	if len(mmSaveOrderWithExpiration.expectations) > 0 {
		mmSaveOrderWithExpiration.mock.t.Fatalf("Some expectations are already set for the Store.SaveOrderWithExpiration method")
	}

	mmSaveOrderWithExpiration.mock.funcSaveOrderWithExpiration = f
	return mmSaveOrderWithExpiration.mock
}

// When sets expectation for the Store.SaveOrderWithExpiration which will trigger the result defined by the following
// Then helper
func (mmSaveOrderWithExpiration *mStoreMockSaveOrderWithExpiration) When(order pb.Order, expiration time.Duration) *StoreMockSaveOrderWithExpirationExpectation {
	if mmSaveOrderWithExpiration.mock.funcSaveOrderWithExpiration != nil {
		mmSaveOrderWithExpiration.mock.t.Fatalf("StoreMock.SaveOrderWithExpiration mock is already set by Set")
	}

	expectation := &StoreMockSaveOrderWithExpirationExpectation{
		mock:   mmSaveOrderWithExpiration.mock,
		params: &StoreMockSaveOrderWithExpirationParams{order, expiration},
	}
	mmSaveOrderWithExpiration.expectations = append(mmSaveOrderWithExpiration.expectations, expectation)
	return expectation
}

// Then sets up Store.SaveOrderWithExpiration return parameters for the expectation previously defined by the When method
func (e *StoreMockSaveOrderWithExpirationExpectation) Then(err error) *StoreMock {
	e.results = &StoreMockSaveOrderWithExpirationResults{err}
	return e.mock
}

// SaveOrderWithExpiration implements Store
func (mmSaveOrderWithExpiration *StoreMock) SaveOrderWithExpiration(order pb.Order, expiration time.Duration) (err error) {
	mm_atomic.AddUint64(&mmSaveOrderWithExpiration.beforeSaveOrderWithExpirationCounter, 1)
	defer mm_atomic.AddUint64(&mmSaveOrderWithExpiration.afterSaveOrderWithExpirationCounter, 1)

	if mmSaveOrderWithExpiration.inspectFuncSaveOrderWithExpiration != nil {
		mmSaveOrderWithExpiration.inspectFuncSaveOrderWithExpiration(order, expiration)
	}

	mm_params := &StoreMockSaveOrderWithExpirationParams{order, expiration}

	// Record call args
	mmSaveOrderWithExpiration.SaveOrderWithExpirationMock.mutex.Lock()
	mmSaveOrderWithExpiration.SaveOrderWithExpirationMock.callArgs = append(mmSaveOrderWithExpiration.SaveOrderWithExpirationMock.callArgs, mm_params)
	mmSaveOrderWithExpiration.SaveOrderWithExpirationMock.mutex.Unlock()

	for _, e := range mmSaveOrderWithExpiration.SaveOrderWithExpirationMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSaveOrderWithExpiration.SaveOrderWithExpirationMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSaveOrderWithExpiration.SaveOrderWithExpirationMock.defaultExpectation.Counter, 1)
		mm_want := mmSaveOrderWithExpiration.SaveOrderWithExpirationMock.defaultExpectation.params
		mm_got := StoreMockSaveOrderWithExpirationParams{order, expiration}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSaveOrderWithExpiration.t.Errorf("StoreMock.SaveOrderWithExpiration got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSaveOrderWithExpiration.SaveOrderWithExpirationMock.defaultExpectation.results
		if mm_results == nil {
			mmSaveOrderWithExpiration.t.Fatal("No results are set for the StoreMock.SaveOrderWithExpiration")
		}
		return (*mm_results).err
	}
	if mmSaveOrderWithExpiration.funcSaveOrderWithExpiration != nil {
		return mmSaveOrderWithExpiration.funcSaveOrderWithExpiration(order, expiration)
	}
	mmSaveOrderWithExpiration.t.Fatalf("Unexpected call to StoreMock.SaveOrderWithExpiration. %v %v", order, expiration)
	return
}

// SaveOrderWithExpirationAfterCounter returns a count of finished StoreMock.SaveOrderWithExpiration invocations
func (mmSaveOrderWithExpiration *StoreMock) SaveOrderWithExpirationAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSaveOrderWithExpiration.afterSaveOrderWithExpirationCounter)
}

// SaveOrderWithExpirationBeforeCounter returns a count of StoreMock.SaveOrderWithExpiration invocations
func (mmSaveOrderWithExpiration *StoreMock) SaveOrderWithExpirationBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSaveOrderWithExpiration.beforeSaveOrderWithExpirationCounter)
}

// Calls returns a list of arguments used in each call to StoreMock.SaveOrderWithExpiration.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSaveOrderWithExpiration *mStoreMockSaveOrderWithExpiration) Calls() []*StoreMockSaveOrderWithExpirationParams {
	mmSaveOrderWithExpiration.mutex.RLock()

	argCopy := make([]*StoreMockSaveOrderWithExpirationParams, len(mmSaveOrderWithExpiration.callArgs))
	copy(argCopy, mmSaveOrderWithExpiration.callArgs)

	mmSaveOrderWithExpiration.mutex.RUnlock()

	return argCopy
}

// MinimockSaveOrderWithExpirationDone returns true if the count of the SaveOrderWithExpiration invocations corresponds
// the number of defined expectations
func (m *StoreMock) MinimockSaveOrderWithExpirationDone() bool {
	for _, e := range m.SaveOrderWithExpirationMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SaveOrderWithExpirationMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSaveOrderWithExpirationCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSaveOrderWithExpiration != nil && mm_atomic.LoadUint64(&m.afterSaveOrderWithExpirationCounter) < 1 {
		return false
	}
	return true
}

// MinimockSaveOrderWithExpirationInspect logs each unmet expectation
func (m *StoreMock) MinimockSaveOrderWithExpirationInspect() {
	for _, e := range m.SaveOrderWithExpirationMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StoreMock.SaveOrderWithExpiration with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SaveOrderWithExpirationMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSaveOrderWithExpirationCounter) < 1 {
		if m.SaveOrderWithExpirationMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to StoreMock.SaveOrderWithExpiration")
		} else {
			m.t.Errorf("Expected call to StoreMock.SaveOrderWithExpiration with params: %#v", *m.SaveOrderWithExpirationMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSaveOrderWithExpiration != nil && mm_atomic.LoadUint64(&m.afterSaveOrderWithExpirationCounter) < 1 {
		m.t.Error("Expected call to StoreMock.SaveOrderWithExpiration")
	}
}

type mStoreMockSavePosition struct {
	mock               *StoreMock
	defaultExpectation *StoreMockSavePositionExpectation
	expectations       []*StoreMockSavePositionExpectation

	callArgs []*StoreMockSavePositionParams
	mutex    sync.RWMutex
}

// StoreMockSavePositionExpectation specifies expectation struct of the Store.SavePosition
type StoreMockSavePositionExpectation struct {
	mock    *StoreMock
	params  *StoreMockSavePositionParams
	results *StoreMockSavePositionResults
	Counter uint64
}

// StoreMockSavePositionParams contains parameters of the Store.SavePosition
type StoreMockSavePositionParams struct {
	t1 pb.TotalPosition
}

// StoreMockSavePositionResults contains results of the Store.SavePosition
type StoreMockSavePositionResults struct {
	err error
}

// Expect sets up expected params for Store.SavePosition
func (mmSavePosition *mStoreMockSavePosition) Expect(t1 pb.TotalPosition) *mStoreMockSavePosition {
	if mmSavePosition.mock.funcSavePosition != nil {
		mmSavePosition.mock.t.Fatalf("StoreMock.SavePosition mock is already set by Set")
	}

	if mmSavePosition.defaultExpectation == nil {
		mmSavePosition.defaultExpectation = &StoreMockSavePositionExpectation{}
	}

	mmSavePosition.defaultExpectation.params = &StoreMockSavePositionParams{t1}
	for _, e := range mmSavePosition.expectations {
		if minimock.Equal(e.params, mmSavePosition.defaultExpectation.params) {
			mmSavePosition.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSavePosition.defaultExpectation.params)
		}
	}

	return mmSavePosition
}

// Inspect accepts an inspector function that has same arguments as the Store.SavePosition
func (mmSavePosition *mStoreMockSavePosition) Inspect(f func(t1 pb.TotalPosition)) *mStoreMockSavePosition {
	if mmSavePosition.mock.inspectFuncSavePosition != nil {
		mmSavePosition.mock.t.Fatalf("Inspect function is already set for StoreMock.SavePosition")
	}

	mmSavePosition.mock.inspectFuncSavePosition = f

	return mmSavePosition
}

// Return sets up results that will be returned by Store.SavePosition
func (mmSavePosition *mStoreMockSavePosition) Return(err error) *StoreMock {
	if mmSavePosition.mock.funcSavePosition != nil {
		mmSavePosition.mock.t.Fatalf("StoreMock.SavePosition mock is already set by Set")
	}

	if mmSavePosition.defaultExpectation == nil {
		mmSavePosition.defaultExpectation = &StoreMockSavePositionExpectation{mock: mmSavePosition.mock}
	}
	mmSavePosition.defaultExpectation.results = &StoreMockSavePositionResults{err}
	return mmSavePosition.mock
}

//Set uses given function f to mock the Store.SavePosition method
func (mmSavePosition *mStoreMockSavePosition) Set(f func(t1 pb.TotalPosition) (err error)) *StoreMock {
	if mmSavePosition.defaultExpectation != nil {
		mmSavePosition.mock.t.Fatalf("Default expectation is already set for the Store.SavePosition method")
	}

	if len(mmSavePosition.expectations) > 0 {
		mmSavePosition.mock.t.Fatalf("Some expectations are already set for the Store.SavePosition method")
	}

	mmSavePosition.mock.funcSavePosition = f
	return mmSavePosition.mock
}

// When sets expectation for the Store.SavePosition which will trigger the result defined by the following
// Then helper
func (mmSavePosition *mStoreMockSavePosition) When(t1 pb.TotalPosition) *StoreMockSavePositionExpectation {
	if mmSavePosition.mock.funcSavePosition != nil {
		mmSavePosition.mock.t.Fatalf("StoreMock.SavePosition mock is already set by Set")
	}

	expectation := &StoreMockSavePositionExpectation{
		mock:   mmSavePosition.mock,
		params: &StoreMockSavePositionParams{t1},
	}
	mmSavePosition.expectations = append(mmSavePosition.expectations, expectation)
	return expectation
}

// Then sets up Store.SavePosition return parameters for the expectation previously defined by the When method
func (e *StoreMockSavePositionExpectation) Then(err error) *StoreMock {
	e.results = &StoreMockSavePositionResults{err}
	return e.mock
}

// SavePosition implements Store
func (mmSavePosition *StoreMock) SavePosition(t1 pb.TotalPosition) (err error) {
	mm_atomic.AddUint64(&mmSavePosition.beforeSavePositionCounter, 1)
	defer mm_atomic.AddUint64(&mmSavePosition.afterSavePositionCounter, 1)

	if mmSavePosition.inspectFuncSavePosition != nil {
		mmSavePosition.inspectFuncSavePosition(t1)
	}

	mm_params := &StoreMockSavePositionParams{t1}

	// Record call args
	mmSavePosition.SavePositionMock.mutex.Lock()
	mmSavePosition.SavePositionMock.callArgs = append(mmSavePosition.SavePositionMock.callArgs, mm_params)
	mmSavePosition.SavePositionMock.mutex.Unlock()

	for _, e := range mmSavePosition.SavePositionMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSavePosition.SavePositionMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSavePosition.SavePositionMock.defaultExpectation.Counter, 1)
		mm_want := mmSavePosition.SavePositionMock.defaultExpectation.params
		mm_got := StoreMockSavePositionParams{t1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSavePosition.t.Errorf("StoreMock.SavePosition got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSavePosition.SavePositionMock.defaultExpectation.results
		if mm_results == nil {
			mmSavePosition.t.Fatal("No results are set for the StoreMock.SavePosition")
		}
		return (*mm_results).err
	}
	if mmSavePosition.funcSavePosition != nil {
		return mmSavePosition.funcSavePosition(t1)
	}
	mmSavePosition.t.Fatalf("Unexpected call to StoreMock.SavePosition. %v", t1)
	return
}

// SavePositionAfterCounter returns a count of finished StoreMock.SavePosition invocations
func (mmSavePosition *StoreMock) SavePositionAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSavePosition.afterSavePositionCounter)
}

// SavePositionBeforeCounter returns a count of StoreMock.SavePosition invocations
func (mmSavePosition *StoreMock) SavePositionBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSavePosition.beforeSavePositionCounter)
}

// Calls returns a list of arguments used in each call to StoreMock.SavePosition.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSavePosition *mStoreMockSavePosition) Calls() []*StoreMockSavePositionParams {
	mmSavePosition.mutex.RLock()

	argCopy := make([]*StoreMockSavePositionParams, len(mmSavePosition.callArgs))
	copy(argCopy, mmSavePosition.callArgs)

	mmSavePosition.mutex.RUnlock()

	return argCopy
}

// MinimockSavePositionDone returns true if the count of the SavePosition invocations corresponds
// the number of defined expectations
func (m *StoreMock) MinimockSavePositionDone() bool {
	for _, e := range m.SavePositionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SavePositionMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSavePositionCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSavePosition != nil && mm_atomic.LoadUint64(&m.afterSavePositionCounter) < 1 {
		return false
	}
	return true
}

// MinimockSavePositionInspect logs each unmet expectation
func (m *StoreMock) MinimockSavePositionInspect() {
	for _, e := range m.SavePositionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StoreMock.SavePosition with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SavePositionMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSavePositionCounter) < 1 {
		if m.SavePositionMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to StoreMock.SavePosition")
		} else {
			m.t.Errorf("Expected call to StoreMock.SavePosition with params: %#v", *m.SavePositionMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSavePosition != nil && mm_atomic.LoadUint64(&m.afterSavePositionCounter) < 1 {
		m.t.Error("Expected call to StoreMock.SavePosition")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *StoreMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockDeleteOrderInspect()

		m.MinimockGetOrderInspect()

		m.MinimockGetPositionInspect()

		m.MinimockSaveOrderInspect()

		m.MinimockSaveOrderWithExpirationInspect()

		m.MinimockSavePositionInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *StoreMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *StoreMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockDeleteOrderDone() &&
		m.MinimockGetOrderDone() &&
		m.MinimockGetPositionDone() &&
		m.MinimockSaveOrderDone() &&
		m.MinimockSaveOrderWithExpirationDone() &&
		m.MinimockSavePositionDone()
}
